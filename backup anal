/**
 * Analysis Dashboard - ë ˆê±°ì‹œ í˜¸í™˜ì„± ë° ê²Œì´ì§€ ì‹œìŠ¤í…œ
 * ìƒˆë¡œìš´ ëª¨ë“ˆ êµ¬ì¡°ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì¤‘
 */

// ë ˆê±°ì‹œ í˜¸í™˜ì„±ì„ ìœ„í•œ TradingAnalyticsPlatform í´ë˜ìŠ¤
class TradingAnalyticsPlatform {
    constructor() {
        console.log('âš ï¸ TradingAnalyticsPlatformì€ ë ˆê±°ì‹œ í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€ë©ë‹ˆë‹¤.');
        console.log('ğŸ’¡ ìƒˆë¡œìš´ AnalysisMainControllerë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
        
        this.isInitialized = false;
        this.whaleTrades = [];
        this.currentSymbol = 'BTCUSDT';
        this.whaleThreshold = 50;
        
        // ìƒˆë¡œìš´ ì‹œìŠ¤í…œê³¼ ì—°ê²°
        this.connectToNewSystem();
    }

    connectToNewSystem() {
        // ìƒˆë¡œìš´ ë°ì´í„° ë§¤ë‹ˆì €ì™€ ì—°ê²°
        if (window.AnalysisDataManager) {
            this.dataManager = window.AnalysisDataManager;
        }
        
        // ìƒˆë¡œìš´ ìœ í‹¸ë¦¬í‹°ì™€ ì—°ê²°
        if (window.AnalysisUtils) {
            this.utils = window.AnalysisUtils;
        }
    }

    // ë ˆê±°ì‹œ ë©”ì„œë“œë“¤ - ìƒˆë¡œìš´ ì‹œìŠ¤í…œìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
    init() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ init() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸');
        if (window.AnalysisMainController) {
            return window.AnalysisMainController.start();
        }
    }

    startTracking() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startTracking() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸');
        if (window.AnalysisMainController) {
            return window.AnalysisMainController.start();
        }
    }

    stopTracking() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ stopTracking() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸');
        if (window.AnalysisMainController) {
            return window.AnalysisMainController.stop();
        }
    }

    // ê²Œì´ì§€ ì‹œìŠ¤í…œ (ë ˆê±°ì‹œ ìœ ì§€)
    runWhaleGaugeTest() {
        console.log('ğŸ§ª ë ˆê±°ì‹œ ê²Œì´ì§€ í…ŒìŠ¤íŠ¸ ì‹¤í–‰');
        this.testWhaleGauge();
    }

    testWhaleGauge() {
        console.log('ğŸ”§ ë ˆê±°ì‹œ ê²Œì´ì§€ í…ŒìŠ¤íŠ¸');
        
        // ê°„ë‹¨í•œ ê²Œì´ì§€ í…ŒìŠ¤íŠ¸
        const testValues = [25, 50, 75, 90, 10];
        let index = 0;
        
        const testInterval = setInterval(() => {
            if (index >= testValues.length) {
                clearInterval(testInterval);
                console.log('âœ… ê²Œì´ì§€ í…ŒìŠ¤íŠ¸ ì™„ë£Œ');
                return;
            }
            
            const value = testValues[index];
            this.updateGaugeDisplay(value, 100);
            index++;
        }, 1000);
    }

    updateGaugeDisplay(ratio, tradeCount) {
        // ê²Œì´ì§€ ì—…ë°ì´íŠ¸ ë¡œì§
        const gaugeFill = document.getElementById('ratio-fill');
        const ratioValue = document.getElementById('longshort-ratio');
        
        if (gaugeFill) {
            gaugeFill.style.width = `${Math.min(100, Math.max(0, ratio * 100))}%`;
        }
        
        if (ratioValue) {
            ratioValue.textContent = ratio.toFixed(2);
        }
    }

    // ë ˆê±°ì‹œ ë°ì´í„° ìƒì„± (ê°œë°œìš©)
    generateDemoData() {
        return {
            whale: {
                trades: [
                    {
                        id: '1',
                        symbol: 'BTCUSDT',
                        price: 45000,
                        amount: 2.5,
                        side: 'buy',
                        timestamp: Date.now() - 1000,
                        level: 2
                    },
                    {
                        id: '2',
                        symbol: 'ETHUSDT',
                        price: 3200,
                        amount: 15,
                        side: 'sell',
                        timestamp: Date.now() - 2000,
                        level: 1
                    }
                ],
                stats: {
                    totalVolume: 125000,
                    largeTrades: 2
                }
            },
            realtime: {
                price: 45000,
                trades: []
            }
        };
    }

    // ë ˆê±°ì‹œ ë©”ì„œë“œë“¤ - ë”ë¯¸ êµ¬í˜„
    initializeComponents() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ initializeComponents() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    initializeWhaleTracker() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ initializeWhaleTracker() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startWhaleSimulation() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startWhaleSimulation() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    updateGaugeFromRecentTrades() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ updateGaugeFromRecentTrades() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    updateWhaleLSRatio() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ updateWhaleLSRatio() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    updateWhaleHeaderGauge() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ updateWhaleHeaderGauge() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    initializeCharts() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ initializeCharts() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    loadInitialData() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ loadInitialData() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    generateInitialWhaleData() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ generateInitialWhaleData() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
        return this.generateDemoData();
    }

    switchTab() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ switchTab() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    initializeTab() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ initializeTab() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startAllTracking() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startAllTracking() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    stopAllTracking() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ stopAllTracking() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    updateGlobalStatus() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ updateGlobalStatus() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    setupEventListeners() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ setupEventListeners() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    initializeWeb3() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ initializeWeb3() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    enableSimulationMode() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ enableSimulationMode() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startBitcoinTracking() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startBitcoinTracking() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    connectBitcoinWebSocket() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ connectBitcoinWebSocket() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    processBitcoinWebSocketData() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ processBitcoinWebSocketData() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    processMempoolBlocks() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ processMempoolBlocks() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    updateBitcoinMempoolStats() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ updateBitcoinMempoolStats() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startBitcoinPolling() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startBitcoinPolling() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    processBitcoinBlockTransactions() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ processBitcoinBlockTransactions() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    extractFromAddress() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ extractFromAddress() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    extractToAddress() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ extractToAddress() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startBitcoinSimulation() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startBitcoinSimulation() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    generateSimulatedBtcTx() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ generateSimulatedBtcTx() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    generateSimulatedMempoolStats() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ generateSimulatedMempoolStats() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startEthereumTracking() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startEthereumTracking() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startEthereumSimulation() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startEthereumSimulation() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    generateSimulatedEthTx() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ generateSimulatedEthTx() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startEthereumWebSocketTracking() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startEthereumWebSocketTracking() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startEthereumPollingTracking() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ startEthereumPollingTracking() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    pollBlocks() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ pollBlocks() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    processEthereumBlock() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ processEthereumBlock() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    updateWhaleDisplay() {
        console.log('ğŸ”„ ë ˆê±°ì‹œ updateWhaleDisplay() -> ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©');
    }

    startRealtimeTracking() {
// Whale Tracking Analysis JavaScript
class TradingAnalyticsPlatform {
    constructor() {
        this.isTracking = false;
        this.currentTab = 'whales';
        this.charts = {};
        this.intervals = {};
        
        // Whale tracking - ê°œì„ ëœ ë²„ì „
        this.whaleTracker = null;
        this.btcThreshold = 100000; // $100k
        this.ethThreshold = 100000; // $100k
        this.allTransactions = [];
        this.currentFilter = 'all';
        this.displayedCount = 20;
        
        // Stats object initialization
        this.stats = {
            btcCount: 0,
            ethCount: 0,
            totalVolume: 0,
            lastUpdate: Date.now()
        };
        
        // ê±°ë˜ì†Œ ì£¼ì†Œ ë§¤í•‘ ì¶”ê°€
        this.exchangeNames = {
            '0x28c6c06298d514db089934071355e5743bf21d60': 'Binance',
            '0x21a31ee1afc51d94c2efccaa2092ad1028285549': 'Binance',
            '0x564286362092d8e7936f0549571a803b203aaced': 'Binance',
            '0x6262998ced04146fa42253a5c0af90ca02dfd2a3': 'Coinbase',
            '0xa9d1e08c7793af67e9d92fe308d5697fb81d3e43': 'Coinbase',
            '0x77696bb39917c91a0c3908d577d5e322095425ca': 'Coinbase',
            '0x503828976d22510aad0201ac7ec88293211d23da': 'Coinbase'
        };
        
        // Liquidations
        this.liquidationData = {
            long: { amount: 0, count: 0 },
            short: { amount: 0, count: 0 },
            history: []
        };
        
        // Long/Short ratios
        this.longShortRatios = {
            overall: { long: 50, short: 50 },
            exchanges: {
                binance: { long: 60, short: 40 },
                okx: { long: 55, short: 45 }
            }
        };
        
        // Realtime trades
        this.realtimeTrades = [];
        this.realtimeSymbol = 'BTCUSDT';
        this.realtimePaused = false;
        
        // Technical indicators
        this.indicators = {
            rsi: 50,
            macd: 0,
            bb: 'middle',
            stoch: 50
        };
        
        // Fear & Greed Index
        this.fearGreedIndex = {
            value: 50,
            label: 'ì¤‘ë¦½',
            factors: {
                volatility: 50,
                volume: 50,
                social: 50,
                survey: 50
            }
        };
        
        // Orderbook
        this.orderbook = {
            asks: [],
            bids: [],
            symbol: 'BTCUSDT'
        };
        
        // Recent trades for gauge calculation
        this.recentTrades = [];
        
        // ì „ì—­ ê°ì²´ë¡œ ì„¤ì •
        window.tradingPlatform = this;
        
        this.init();
    }
    
    init() {
        console.log('ğŸš€ Initializing Trading Analytics Platform...');
        
        // DOMì´ ì™„ì „íˆ ë¡œë“œëœ í›„ ì´ˆê¸°í™”
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initializeComponents());
        } else {
            this.initializeComponents();
        }
    }

    initializeComponents() {
        console.log('ğŸ”§ Initializing platform components...');
        this.initializeWhaleTracker();
        // this.initializeLiquidationTracker(); // ... other trackers
        
        // Deprecated: Whale gauge initialization is disabled.
        // if (this.settings.enableWhaleGauge) {
        //     setTimeout(() => this.initializeWhaleGauge(), 1000); 
        // }
    }

    initializeWhaleTracker() {
        console.log('ğŸ‹ Initializing WhaleTracker...');
        
        // WhaleTracker ëª¨ë“ˆ ì´ˆê¸°í™”
        if (typeof WhaleTracker !== 'undefined') {
            try {
                // ì»¨í…Œì´ë„ˆ ì—†ì´ WhaleTracker ì´ˆê¸°í™”
                this.whaleTracker = new WhaleTracker(null, {}); // ë¹ˆ ì„¤ì • ê°ì²´ ì „ë‹¬
                console.log('ğŸ‹ WhaleTracker module initialized');
            } catch (error) {
                console.error('âŒ Error initializing WhaleTracker:', error);
                // Fallback to simulation mode
                this.startWhaleSimulation();
            }
        } else {
            console.warn('WhaleTracker module not found, using fallback');
            // ë°ëª¨ ê±°ë˜ ìƒì„±
            this.startWhaleSimulation();
        }
    }

    startWhaleSimulation() {
        console.log('ğŸ‹ Starting whale trade simulation...');
        
        // ì´ˆê¸° ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆìœ¼ë©´ ê¸°ë³¸ ê±°ë˜ ì¶”ê°€
        if (!this.recentTrades) this.recentTrades = [];
        
        const generateRandomTrade = () => {
            if (!this.isTracking) return;
            
            const exchanges = ['BINANCE', 'BYBIT', 'OKX', 'BITGET', 'MEXC'];
            const exchange = exchanges[Math.floor(Math.random() * exchanges.length)];
            const price = 100000 + (Math.random() - 0.5) * 10000; // BTC price around 100k
            const amount = Math.random() * 50 + 10; // 10-60 BTC
            const side = Math.random() > 0.5 ? 'BUY' : 'SELL';
            
            this.addSimulatedTrade(exchange, price, amount, side);
        };
        
        // ì¦‰ì‹œ ì²« ê±°ë˜ ìƒì„±
        generateRandomTrade();
        
        // ì´ˆê¸° ê±°ë˜ ëª‡ ê°œ ë” ìƒì„±
        for (let i = 1; i < 10; i++) {
            setTimeout(() => generateRandomTrade(), i * 300);
        }
        
        // ì§€ì†ì ìœ¼ë¡œ ê±°ë˜ ìƒì„±
        this.whaleSimulationInterval = setInterval(() => {
            if (Math.random() < 0.4) { // 40% í™•ë¥ ë¡œ ê±°ë˜ ìƒì„± (ë” ìì£¼)
                generateRandomTrade();
            }
        }, 1500); // 1.5ì´ˆë§ˆë‹¤ ì²´í¬
    }

    addSimulatedTrade(exchange, price, amount, side) {
        const tradeAmount = price * amount;
        
        // $100k ì´ìƒë§Œ í‘œì‹œ
        if (tradeAmount < 100000) return;

        console.log(`ğŸ’° Adding simulated trade: ${exchange} ${side} ${this.formatAmount(tradeAmount)}`);

        // ê±°ë˜ë¥¼ ë¡±/ìˆ ì¶”ì ì— ì¶”ê°€ (ë§ˆì§€ë§‰ 20ê°œë§Œ ìœ ì§€)
        if (!this.recentTrades) this.recentTrades = [];
        this.recentTrades.push({
            timestamp: Date.now(),
            side: side,
            amount: tradeAmount
        });

        // ë§ˆì§€ë§‰ 20ê°œ ê±°ë˜ë§Œ ìœ ì§€
        if (this.recentTrades.length > 20) {
            this.recentTrades = this.recentTrades.slice(-20);
        }

        console.log(`ğŸ“Š Recent trades count: ${this.recentTrades.length}`);

        // ì‹¤ì‹œê°„ ê²Œì´ì§€ ì—…ë°ì´íŠ¸ (ë§ˆì§€ë§‰ 20ê°œ ê±°ë˜ ê¸°ë°˜)
        this.updateGaugeFromRecentTrades();
    }

    updateGaugeFromRecentTrades() {
        if (!this.recentTrades || this.recentTrades.length === 0) {
            this.updateWhaleRatioDisplay(50, 0);
            return;
        }

        console.log('ğŸ“Š Calculating from', this.recentTrades.length, 'trades');

        // ë¡±/ìˆ ë³¼ë¥¨ ê³„ì‚° (ë§ˆì§€ë§‰ 20ê°œ ê±°ë˜) - ì¼ê´€ëœ í•„í„°ë§
        const longVolume = this.recentTrades
            .filter(t => t.side === 'BUY')
            .reduce((sum, t) => sum + t.amount, 0);
        
        const shortVolume = this.recentTrades
            .filter(t => t.side === 'SELL')
            .reduce((sum, t) => sum + t.amount, 0);

        // ë¹„ìœ¨ ê³„ì‚°
        const totalVolume = longVolume + shortVolume;
        let longRatio = 50; // ê¸°ë³¸ê°’

        if (totalVolume > 0) {
            longRatio = (longVolume / totalVolume) * 100;
        }

        console.log(`ğŸ“Š Real-time gauge update: ${longRatio.toFixed(1)}% (${this.recentTrades.length}/20 trades, Long: $${(longVolume/1000000).toFixed(1)}M, Short: $${(shortVolume/1000000).toFixed(1)}M)`);

        // ê²Œì´ì§€ ì—…ë°ì´íŠ¸
        this.updateWhaleRatioDisplay(longRatio, this.recentTrades.length);
    }

    updateWhaleLSRatio() {
        if (!this.recentTrades || this.recentTrades.length === 0) {
            this.updateWhaleHeaderGauge(50);
            return;
        }

        console.log('ğŸ“Š Calculating from', this.recentTrades.length, 'trades');

        // ë§ˆì§€ë§‰ 20ê°œ ê±°ë˜ë§Œ ìœ ì§€
        if (this.recentTrades.length > 20) {
            this.recentTrades = this.recentTrades.slice(-20);
        }

        // ë¡±/ìˆ ë³¼ë¥¨ ê³„ì‚° (ë§ˆì§€ë§‰ 20ê°œ ê±°ë˜)
        const longVolume = this.recentTrades
            .filter(t => t.side === 'BUY' || t.side === 'buy')
            .reduce((sum, t) => sum + t.amount, 0);
        
        const shortVolume = this.recentTrades
            .filter(t => t.side === 'SELL' || t.side === 'sell')
            .reduce((sum, t) => sum + t.amount, 0);

        // ë¹„ìœ¨ ê³„ì‚°
        const totalVolume = longVolume + shortVolume;
        const longRatio = totalVolume > 0 ? (longVolume / totalVolume) * 100 : 50;

        this.updateWhaleHeaderGauge(longRatio);
    }

    updateWhaleHeaderGauge(longRatio) {
        console.log('ğŸ¯ updateWhaleHeaderGauge called with longRatio:', longRatio);
        
        // ë‹¨ì¼ ê²Œì´ì§€ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ì‚¬ìš©
        this.updateWhaleRatioDisplay(longRatio, 0);
    }

    // ê²Œì´ì§€ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ ì¶”ê°€
    testWhaleGauge() {
        console.log('ğŸ§ª Testing whale gauge...');
        
        let testRatio = 20; // ì‹œì‘ê°’
        const testInterval = setInterval(() => {
            this.updateWhaleRatioDisplay(testRatio, 0);
            testRatio += 10;
            
            if (testRatio > 80) {
                clearInterval(testInterval);
                console.log('ğŸ§ª Gauge test completed');
                
                // ë‹¤ì‹œ ì‹¤ì œ ê°’ìœ¼ë¡œ ëŒì•„ê°€ê¸°
                setTimeout(() => {
                    this.updateWhaleLSRatio();
                }, 2000);
            }
        }, 500);
    }

    // í…ŒìŠ¤íŠ¸ ê±°ë˜ ì¶”ê°€ í•¨ìˆ˜
    addTestTrades() {
        console.log('ğŸ§ª Adding test trades...');
        
        // í…ŒìŠ¤íŠ¸ ê±°ë˜ë“¤ ì¶”ê°€
        const testTrades = [
            { exchange: 'BINANCE', side: 'BUY', amount: 25 },
            { exchange: 'BYBIT', side: 'SELL', amount: 15 },
            { exchange: 'OKX', side: 'BUY', amount: 30 },
            { exchange: 'BITGET', side: 'BUY', amount: 20 },
            { exchange: 'MEXC', side: 'SELL', amount: 10 }
        ];

        testTrades.forEach((trade, index) => {
            setTimeout(() => {
                const price = 100000 + (Math.random() - 0.5) * 10000;
                const quantity = trade.amount;
                this.addSimulatedTrade(trade.exchange, price, quantity, trade.side);
            }, index * 500);
        });
    }

    getTradeLevel(amount) {
        if (amount >= 1000000) return 3; // $1M+
        if (amount >= 500000) return 2;  // $500k+
        if (amount >= 250000) return 1;  // $250k+
        return 0; // $100k+
    }

    formatAmount(amount) {
        if (amount >= 1000000) {
            return `$${(amount / 1000000).toFixed(1)}M`;
        }
        return `$${(amount / 1000).toFixed(1)}K`;
    }

    initializeCharts() {
        console.log('ğŸ“Š Initializing charts...');
        // Chart.js ì°¨íŠ¸ë“¤ ì´ˆê¸°í™”ëŠ” ê° íƒ­ì´ í™œì„±í™”ë  ë•Œ ì‹¤í–‰
    }

    loadInitialData() {
        // Generate simulation data first
        this.generateSimulationData();
        
        // Initial whale data display
        this.generateInitialWhaleData();
        
        // Fear & Greed Index initialization moved to after DOM is ready
        setTimeout(() => {
            try {
                this.updateFearGreedIndex();
            } catch (error) {
                console.warn('Fear & Greed Index elements not ready yet:', error);
            }
        }, 1000);
    }

    generateInitialWhaleData() {
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì¦‰ì‹œ ë³´ì—¬ì¤„ ìƒ˜í”Œ ê³ ë˜ ê±°ë˜ ìƒì„±
        const sampleWhales = [
            {
                id: 'initial_btc_1',
                hash: generateRandomHash(),
                amount: 156.789,
                type: 'bitcoin',
                timestamp: Date.now() - 300000, // 5ë¶„ ì „
                fromAddress: generateRandomAddress(),
                toAddress: generateRandomAddress(),
                usdValue: 156.789 * 104000,
                fee: 0.002345,
                size: 1024,
                confirmed: true,
                blockHeight: 875432
            },
            {
                id: 'initial_btc_2',
                hash: generateRandomHash(),
                amount: 89.234,
                type: 'bitcoin',
                timestamp: Date.now() - 600000, // 10ë¶„ ì „
                fromAddress: generateRandomAddress(),
                toAddress: generateRandomAddress(),
                usdValue: 89.234 * 104000,
                fee: 0.001876,
                size: 856,
                confirmed: false,
                isMempool: true
            },
            {
                id: 'initial_eth_1',
                hash: generateRandomHash(),
                amount: 2456.78,
                type: 'ethereum',
                timestamp: Date.now() - 450000, // 7.5ë¶„ ì „
                fromAddress: generateRandomAddress(),
                toAddress: generateRandomAddress(),
                usdValue: 2456.78 * 3400,
                fee: 0.0234,
                size: 512,
                confirmed: true,
                blockHeight: 19234567
            }
        ];

        this.allTransactions = sampleWhales;
        this.stats.btcCount = 2;
        this.stats.ethCount = 1;
        this.stats.totalVolume = sampleWhales.reduce((sum, tx) => sum + tx.usdValue, 0);
        
        // ì¦‰ì‹œ í‘œì‹œ ì—…ë°ì´íŠ¸
        this.updateWhaleDisplay();
        this.updateStats();
    }

    switchTab(tabName) {
        if (!tabName || this.currentTab === tabName) return;
        
        // ì´ì „ íƒ­ ë¹„í™œì„±í™”
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        
        // ìƒˆ íƒ­ í™œì„±í™”
        const tabButton = document.querySelector(`[data-tab="${tabName}"]`);
        const tabContent = document.getElementById(`${tabName}-tab`);
        
        if (tabButton && tabContent) {
            tabButton.classList.add('active');
            tabContent.classList.add('active');
            this.currentTab = tabName;
            
            // ê° íƒ­ë³„ ì´ˆê¸°í™”
            this.initializeTab(tabName);
        }
    }

    initializeTab(tabName) {
        switch(tabName) {
            case 'whales':
                this.updateWhaleDisplay();
                break;
            case 'liquidations':
                this.initializeLiquidationChart();
                this.updateLiquidationData();
                break;
            case 'longsshorts':
                this.initializeLongShortChart();
                this.updateLongShortDisplay();
                break;
            case 'realtime':
                this.startRealtimeTracking();
                break;
            case 'indicators':
                this.initializeIndicatorCharts();
                this.updateIndicators();
                break;
            case 'sentiment':
                this.initializeFearGreedGauge();
                this.initializeSentimentChart();
                break;
            case 'heatmap':
                this.generateHeatmap();
                break;
            case 'orderbook':
                this.startOrderbookTracking();
                break;
        }
    }

    startAllTracking() {
        this.isTracking = true;
        // document.getElementById('start-all-tracking').disabled = true;
        // document.getElementById('stop-all-tracking').disabled = false;
        
        this.updateGlobalStatus('connected', 'ì „ì²´ ì¶”ì  ì¤‘...');
        
        // ëª¨ë“  ê¸°ëŠ¥ ì‹œì‘
        this.startWhaleTracking();
        this.startLiquidationTracking();
        this.startLongShortTracking();
        this.startRealtimeTracking();
        this.startIndicatorTracking();
        this.startSentimentTracking();
        
        this.showNotification('ğŸš€ ëª¨ë“  ì¶”ì  ê¸°ëŠ¥ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
    }

    stopAllTracking() {
        this.isTracking = false;
        // document.getElementById('start-all-tracking').disabled = false;
        // document.getElementById('stop-all-tracking').disabled = true;
        
        this.updateGlobalStatus('connecting', 'ëŒ€ê¸° ì¤‘...');
        
        // ëª¨ë“  ê°„ê²© ì •ë¦¬
        Object.values(this.intervals).forEach(interval => {
            if (interval) clearInterval(interval);
        });
        this.intervals = {};
        
        // Whale ê´€ë ¨ ê°„ê²© ì •ë¦¬
        if (this.whaleSimulationInterval) {
            clearInterval(this.whaleSimulationInterval);
            this.whaleSimulationInterval = null;
        }
        this.stopWhaleLSUpdate();
        
        this.showNotification('â¹ï¸ ëª¨ë“  ì¶”ì ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
    }

    updateGlobalStatus(status, text) {
        const statusElement = document.getElementById('global-status');
        if (statusElement) {
            const dot = statusElement.querySelector('.status-dot');
            const textElement = statusElement.querySelector('.status-text');
            
            if (dot && textElement) {
                dot.classList.remove('connecting', 'connected', 'error');
                dot.classList.add(status);
                textElement.textContent = text;
            }
        }
    }
    
    setupEventListeners() {
        // Global controls (ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ ì œê±°)
        // document.getElementById('start-all-tracking')?.addEventListener('click', () => this.startAllTracking());
        // document.getElementById('stop-all-tracking')?.addEventListener('click', () => this.stopAllTracking());
        
        // Tab switching
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.addEventListener('click', (e) => this.switchTab(e.target.dataset.tab));
        });
        
        // Realtime controls
        document.getElementById('realtime-symbol')?.addEventListener('change', (e) => {
            this.realtimeSymbol = e.target.value;
            this.startRealtimeTracking();
        });
        
        document.getElementById('realtime-toggle')?.addEventListener('click', () => {
            this.toggleRealtimeTracking();
        });
        
        // Whale tracking controls
        document.getElementById('btc-threshold')?.addEventListener('change', (e) => {
            this.btcThreshold = parseFloat(e.target.value);
        });
        
        document.getElementById('eth-threshold')?.addEventListener('change', (e) => {
            this.ethThreshold = parseFloat(e.target.value);
        });
        
        document.getElementById('crypto-filter')?.addEventListener('change', (e) => {
            this.currentFilter = e.target.value;
            this.updateWhaleDisplay();
        });
        
        document.getElementById('refresh-data')?.addEventListener('click', () => {
            this.refreshWhaleData();
        });
        
        document.getElementById('load-more')?.addEventListener('click', () => {
            this.loadMoreTransactions();
        });
    }
    
    async initializeWeb3() {
        try {
            console.log('âš¡ Web3 ì´ˆê¸°í™” ì‹œì‘...');
            
            // Web3ê°€ ì—†ì–´ë„ ì‘ë™í•˜ë„ë¡ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì„¤ì •
            this.enableSimulationMode();
            console.log('ğŸ­ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì´ˆê¸°í™” ì™„ë£Œ');
            
            return; // Web3 ì—°ê²° ì‹œë„ ì—†ì´ ë°”ë¡œ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ
            
            // ì—¬ëŸ¬ RPC ì—”ë“œí¬ì¸íŠ¸ ì‹œë„ (ë¬´ë£Œ ê³µê°œ RPC ì‚¬ìš©)
            const rpcEndpoints = [
                'https://eth.llamarpc.com',
                'https://rpc.ankr.com/eth',
                'https://ethereum.publicnode.com',
                'https://eth-mainnet.public.blastapi.io',
                'https://eth.drpc.org'
            ];
            
            let connected = false;
            
            for (const endpoint of rpcEndpoints) {
                try {
                    console.log(`Trying RPC endpoint: ${endpoint}`);
                    
                    // HTTP Provider with timeout
                    const provider = new Web3.providers.HttpProvider(endpoint, {
                        timeout: 10000, // 10ì´ˆ íƒ€ì„ì•„ì›ƒ
                        headers: [
                            {
                                name: 'User-Agent',
                                value: 'Onbit-WhaleTracker/1.0'
                            }
                        ]
                    });
                    
                    this.web3 = new Web3(provider);
                    
                    // ì—°ê²° í…ŒìŠ¤íŠ¸ (íƒ€ì„ì•„ì›ƒ ì¶”ê°€)
                    const blockNumber = await Promise.race([
                        this.web3.eth.getBlockNumber(),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Timeout')), 8000)
                        )
                    ]);
                    
                    console.log(`Connected to ${endpoint}, current block: ${blockNumber}`);
                    this.updateStatus('eth', 'connected', 'HTTP ì—°ê²°ë¨');
                    connected = true;
                    break;
                    
                } catch (error) {
                    console.log(`Failed to connect to ${endpoint}:`, error.message);
                    this.web3 = null;
                    continue;
                }
            }
            
            if (!connected) {
                throw new Error('All RPC endpoints failed');
            }
            
        } catch (error) {
            console.error('Web3 initialization failed:', error);
            this.updateStatus('eth', 'error', 'ì—°ê²° ì‹¤íŒ¨');
            
            // ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì „í™˜
            this.enableSimulationMode();
        }
    }
    
    enableSimulationMode() {
        console.log('Enabling simulation mode for Ethereum tracking');
        this.updateStatus('eth', 'connected', 'ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ');
        this.web3 = null; // Web3 ë¹„í™œì„±í™”
        
        // ì‹œë®¬ë ˆì´ì…˜ ì•Œë¦¼
        this.showNotification('ğŸ”§ ì‹¤ì œ API ì—°ê²° ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì „í™˜ë©ë‹ˆë‹¤.', 'warning');
        
        // 5ì´ˆ í›„ ì¶”ê°€ ì•ˆë‚´ ë©”ì‹œì§€
        setTimeout(() => {
            this.showNotification('ğŸ’¡ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œì—ì„œë„ ê³ ë˜ ì¶”ì ì„ ì²´í—˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!', 'info');
        }, 5000);
    }
    
    startTracking() {
        if (this.isTracking) return;
        
        this.isTracking = true;
        document.getElementById('start-tracking').disabled = true;
        document.getElementById('stop-tracking').disabled = false;
        
        // ìƒíƒœ ì—…ë°ì´íŠ¸
        this.updateStatus('btc', 'connected', 'ì¶”ì  ì¤‘...');
        this.updateStatus('eth', 'connected', 'ì¶”ì  ì¤‘...');
        
        // ë¹„íŠ¸ì½”ì¸ ì¶”ì  ì‹œì‘
        this.startBitcoinTracking();
        
        // ì´ë”ë¦¬ì›€ ì¶”ì  ì‹œì‘
        this.startEthereumTracking();
        
        // UI ì—…ë°ì´íŠ¸ ê°„ê²© ì„¤ì •
        this.trackingInterval = setInterval(() => {
            this.updateLastUpdateTime();
        }, 1000);
        
        this.showNotification('ê³ ë˜ ì¶”ì ì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤!', 'success');
    }
    
    stopTracking() {
        if (!this.isTracking) return;
        
        this.isTracking = false;
        document.getElementById('start-tracking').disabled = false;
        document.getElementById('stop-tracking').disabled = true;
        
        // ìƒíƒœ ì—…ë°ì´íŠ¸
        this.updateStatus('btc', 'connecting', 'ëŒ€ê¸° ì¤‘...');
        this.updateStatus('eth', 'connecting', 'ëŒ€ê¸° ì¤‘...');
        
        // ê°„ê²© ì •ë¦¬
        if (this.trackingInterval) {
            clearInterval(this.trackingInterval);
            this.trackingInterval = null;
        }
        
        this.showNotification('ê³ ë˜ ì¶”ì ì„ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.', 'info');
    }
    
    async startBitcoinTracking() {
        this.updateStatus('btc', 'connecting', 'ë¹„íŠ¸ì½”ì¸ ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì¤‘...');
        this.bitcoinFailCount = 0;

        // WebSocket ì—°ê²° ì‹œë„
        try {
            await this.connectBitcoinWebSocket();
        } catch (error) {
            console.log('WebSocket ì—°ê²° ì‹¤íŒ¨, REST API í´ë§ìœ¼ë¡œ ì „í™˜');
            this.startBitcoinPolling();
        }
    }

    async connectBitcoinWebSocket() {
        return new Promise((resolve, reject) => {
            try {
                this.bitcoinWs = new WebSocket('wss://mempool.space/api/v1/ws');
                
                let connected = false;
                
                this.bitcoinWs.onopen = () => {
                    console.log('âœ… ë¹„íŠ¸ì½”ì¸ WebSocket ì—°ê²° ì„±ê³µ');
                    this.updateStatus('btc', 'connected', 'ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì¤‘');
                    connected = true;
                    
                    // ì‹¤ì‹œê°„ ê±°ë˜ ë°ì´í„° êµ¬ë…
                    this.bitcoinWs.send(JSON.stringify({
                        "action": "want", 
                        "data": ["mempool-blocks", "stats"]
                    }));
                    
                    resolve();
                };

                this.bitcoinWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.processBitcoinWebSocketData(data);
                    } catch (e) {
                        console.error('WebSocket ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:', e);
                    }
                };

                this.bitcoinWs.onerror = (error) => {
                    console.error('ë¹„íŠ¸ì½”ì¸ WebSocket ì˜¤ë¥˜:', error);
                    if (!connected) {
                        reject(error);
                    }
                };

                this.bitcoinWs.onclose = () => {
                    console.log('ë¹„íŠ¸ì½”ì¸ WebSocket ì—°ê²° ì¢…ë£Œ');
                    this.updateStatus('btc', 'reconnecting', 'ì¬ì—°ê²° ì¤‘...');
                    
                    // 3ì´ˆ í›„ ì¬ì—°ê²° ì‹œë„
                    setTimeout(() => {
                        if (this.isTracking) {
                            this.connectBitcoinWebSocket().catch(() => {
                                this.startBitcoinPolling();
                            });
                        }
                    }, 3000);
                };

                // 10ì´ˆ í›„ì—ë„ ì—°ê²°ë˜ì§€ ì•Šìœ¼ë©´ ì‹¤íŒ¨ë¡œ ì²˜ë¦¬
                setTimeout(() => {
                    if (!connected) {
                        reject(new Error('WebSocket ì—°ê²° íƒ€ì„ì•„ì›ƒ'));
                    }
                }, 10000);

            } catch (error) {
                reject(error);
            }
        });
    }

    processBitcoinWebSocketData(data) {
        // ë©¤í’€ ë¸”ë¡ ë°ì´í„° ì²˜ë¦¬
        if (data['mempool-blocks']) {
            const mempoolBlocks = data['mempool-blocks'];
            this.processMempoolBlocks(mempoolBlocks);
        }

        // ë©¤í’€ í†µê³„ ì—…ë°ì´íŠ¸
        if (data.mempoolInfo && data.fees) {
            this.updateBitcoinMempoolStats(data.mempoolInfo, data.vBytesPerSecond || 0, data.fees);
        }
    }

    processMempoolBlocks(blocks) {
        if (!blocks || blocks.length === 0) return;

        blocks.forEach((block, index) => {
            // ìˆ˜ìˆ˜ë£Œê°€ ë†’ì€ ë¸”ë¡ = ê³ ì•¡ ê±°ë˜ í¬í•¨ ê°€ëŠ¥ì„±
            if (block.totalFees > 50000000) { // 0.5 BTC ì´ìƒ ì´ ìˆ˜ìˆ˜ë£Œ
                const estimatedWhaleValue = block.totalFees / 100000000 * 20; // ì¶”ì • ê³ ë˜ ê±°ë˜ í¬ê¸°
                
                const whaleTransaction = {
                    id: `mempool_${Date.now()}_${index}`,
                    hash: `mempool_block_${block.blockSize}_${Date.now()}`,
                    amount: estimatedWhaleValue,
                    type: 'bitcoin',
                    timestamp: Date.now(),
                    fromAddress: 'Multiple Inputs',
                    toAddress: 'Multiple Outputs',
                    usdValue: estimatedWhaleValue * 104000,
                    fee: block.totalFees / 100000000,
                    size: block.blockSize,
                    txCount: block.nTx,
                    medianFee: block.medianFee,
                    confirmed: false,
                    isMempool: true
                };

                // ì¤‘ë³µ ë°©ì§€
                if (!this.allTransactions.find(t => t.id === whaleTransaction.id)) {
                    this.allTransactions.unshift(whaleTransaction);
                    this.stats.btcCount++;
                    this.stats.totalVolume += whaleTransaction.usdValue;
                    
                    // ìµœëŒ€ 200ê°œ ê±°ë˜ë§Œ ìœ ì§€
                    if (this.allTransactions.length > 200) {
                        this.allTransactions = this.allTransactions.slice(0, 200);
                    }
                    
                    this.updateTransactionDisplay();
                    this.updateStats();
                    
                    // ëŒ€í˜• ê±°ë˜ ì•Œë¦¼
                    if (whaleTransaction.usdValue > 10000000) { // $10M ì´ìƒ
                        this.showNotification(
                            `ğŸ‹ ëŒ€í˜• ë¹„íŠ¸ì½”ì¸ ê±°ë˜ ê°ì§€: ${whaleTransaction.amount.toFixed(2)} BTC ($${(whaleTransaction.usdValue/1000000).toFixed(1)}M)`,
                            'whale'
                        );
                    }
                }
            }
        });
    }

    updateBitcoinMempoolStats(mempoolInfo, vBytesPerSecond, fees) {
        // ë©¤í’€ í†µê³„ë¥¼ ê³ ë˜ ì¶”ì  íƒ­ì— í‘œì‹œ
        const statsContainer = document.querySelector('#whale-tracking .stats-grid');
        if (statsContainer) {
            // ê¸°ì¡´ í†µê³„ ë’¤ì— ë©¤í’€ í†µê³„ ì¶”ê°€
            let mempoolStatsElement = document.getElementById('bitcoin-mempool-stats');
            if (!mempoolStatsElement) {
                mempoolStatsElement = document.createElement('div');
                mempoolStatsElement.id = 'bitcoin-mempool-stats';
                mempoolStatsElement.className = 'stat-card mempool-stats';
                statsContainer.appendChild(mempoolStatsElement);
            }
            
            mempoolStatsElement.innerHTML = `
                <h3>ğŸ“Š ë¹„íŠ¸ì½”ì¸ ë©¤í’€ í˜„í™©</h3>
                <div class="mempool-stat-grid">
                    <div class="mempool-stat">
                        <span class="stat-label">ë©¤í’€ í¬ê¸°:</span>
                        <span class="stat-value">${(mempoolInfo.bytes / 1024 / 1024).toFixed(1)} MB</span>
                    </div>
                    <div class="mempool-stat">
                        <span class="stat-label">ëŒ€ê¸° ê±°ë˜:</span>
                        <span class="stat-value">${mempoolInfo.size.toLocaleString()}ê°œ</span>
                    </div>
                    <div class="mempool-stat">
                        <span class="stat-label">ì²˜ë¦¬ ì†ë„:</span>
                        <span class="stat-value">${vBytesPerSecond} vB/s</span>
                    </div>
                    <div class="mempool-stat">
                        <span class="stat-label">ë¹ ë¥¸ ìˆ˜ìˆ˜ë£Œ:</span>
                        <span class="stat-value">${fees.fastestFee} sat/vB</span>
                    </div>
                    <div class="mempool-stat">
                        <span class="stat-label">ê²½ì œì  ìˆ˜ìˆ˜ë£Œ:</span>
                        <span class="stat-value">${fees.economyFee} sat/vB</span>
                    </div>
                    <div class="mempool-stat">
                        <span class="stat-label">ìµœì†Œ ìˆ˜ìˆ˜ë£Œ:</span>
                        <span class="stat-value">${fees.minimumFee} sat/vB</span>
                    </div>
                </div>
            `;
        }
    }

    async startBitcoinPolling() {
        console.log('ğŸ“¡ ë¹„íŠ¸ì½”ì¸ REST API í´ë§ ì‹œì‘');
        this.updateStatus('btc', 'polling', 'REST API ëª¨ë‹ˆí„°ë§ ì¤‘');

        const pollBitcoin = async () => {
            if (!this.isTracking) return;

            try {
                // ìµœì‹  ë¸”ë¡ ë†’ì´ ì¡°íšŒ
                const tipResponse = await fetch('https://mempool.space/api/blocks/tip/height');
                if (!tipResponse.ok) throw new Error('ë¸”ë¡ ë†’ì´ ì¡°íšŒ ì‹¤íŒ¨');
                
                const currentHeight = await tipResponse.json();
                
                // ìµœì‹  ë¸”ë¡ì˜ ê±°ë˜ë“¤ ì¡°íšŒ
                const blockTxsResponse = await fetch(`https://mempool.space/api/block/${currentHeight}/txs/0`);
                if (!blockTxsResponse.ok) throw new Error('ë¸”ë¡ ê±°ë˜ ì¡°íšŒ ì‹¤íŒ¨');
                
                const transactions = await blockTxsResponse.json();
                this.processBitcoinBlockTransactions(transactions, currentHeight);
                
                // ë©¤í’€ í†µê³„ ì¡°íšŒ
                const mempoolResponse = await fetch('https://mempool.space/api/mempool');
                if (mempoolResponse.ok) {
                    const mempoolData = await mempoolResponse.json();
                    
                    // ìˆ˜ìˆ˜ë£Œ ì •ë³´ ì¡°íšŒ
                    const feesResponse = await fetch('https://mempool.space/api/v1/fees/recommended');
                    const feesData = feesResponse.ok ? await feesResponse.json() : {};
                    
                    this.updateBitcoinMempoolStats(mempoolData, 0, feesData);
                }
                
                this.updateStatus('btc', 'connected', 'REST API ëª¨ë‹ˆí„°ë§ ì¤‘');
                this.bitcoinFailCount = 0;
                
            } catch (error) {
                console.error('ë¹„íŠ¸ì½”ì¸ í´ë§ ì˜¤ë¥˜:', error);
                this.bitcoinFailCount++;
                
                if (this.bitcoinFailCount >= 3) {
                    console.log('ğŸ”„ API ì—°ê²° ì‹¤íŒ¨, ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì „í™˜');
                    this.updateStatus('btc', 'simulation', 'ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ');
                    this.startBitcoinSimulation();
                    return;
                } else {
                    this.updateStatus('btc', 'error', `API ì˜¤ë¥˜ (${this.bitcoinFailCount}/3)`);
                }
            }
            
            // 30ì´ˆ í›„ ë‹¤ì‹œ í´ë§
            if (this.isTracking) {
                setTimeout(pollBitcoin, 30000);
            }
        };

        await pollBitcoin();
    }

    processBitcoinBlockTransactions(transactions, blockHeight) {
        if (!transactions || transactions.length === 0) return;

        transactions.forEach(tx => {
            // ì´ ì¶œë ¥ê°’ ê³„ì‚°
            const totalOutput = tx.vout.reduce((sum, output) => sum + output.value, 0);
            const btcAmount = totalOutput / 100000000; // satoshi to BTC
            
            // 50 BTC ì´ìƒ ê±°ë˜ë¥¼ ê³ ë˜ë¡œ ê°„ì£¼ (ì‹¤ì œ ê³ ë˜ ê¸°ì¤€)
            if (btcAmount >= 50) {
                const whaleTransaction = {
                    id: tx.txid,
                    hash: tx.txid,
                    amount: btcAmount,
                    type: 'bitcoin',
                    timestamp: Date.now(),
                    fromAddress: this.extractFromAddress(tx),
                    toAddress: this.extractToAddress(tx),
                    usdValue: btcAmount * 104000, // í˜„ì¬ BTC ê°€ê²©
                    fee: tx.fee / 100000000,
                    size: tx.size,
                    blockHeight: blockHeight,
                    confirmed: true,
                    vsize: tx.vsize || tx.size
                };

                // ì¤‘ë³µ ë°©ì§€
                if (!this.allTransactions.find(t => t.id === whaleTransaction.id)) {
                    this.allTransactions.unshift(whaleTransaction);
                    this.stats.btcCount++;
                    this.stats.totalVolume += whaleTransaction.usdValue;
                    
                    if (this.allTransactions.length > 200) {
                        this.allTransactions = this.allTransactions.slice(0, 200);
                    }
                    
                    this.updateTransactionDisplay();
                    this.updateStats();
                    
                    // ê³ ë˜ ë“±ê¸‰ë³„ ì•Œë¦¼
                    if (whaleTransaction.usdValue > 50000000) { // $50M+ = ì´ˆëŒ€í˜• ê³ ë˜
                        this.showNotification(
                            `ğŸ‹ğŸ‹ğŸ‹ ì´ˆëŒ€í˜• ê³ ë˜: ${whaleTransaction.amount.toFixed(2)} BTC ($${(whaleTransaction.usdValue/1000000).toFixed(0)}M)`,
                            'mega-whale'
                        );
                    } else if (whaleTransaction.usdValue > 10000000) { // $10M+ = ëŒ€í˜• ê³ ë˜
                        this.showNotification(
                            `ğŸ‹ğŸ‹ ëŒ€í˜• ê³ ë˜: ${whaleTransaction.amount.toFixed(2)} BTC ($${(whaleTransaction.usdValue/1000000).toFixed(1)}M)`,
                            'whale'
                        );
                    } else if (whaleTransaction.usdValue > 5000000) { // $5M+ = ì¤‘í˜• ê³ ë˜
                        this.showNotification(
                            `ğŸ‹ ì¤‘í˜• ê³ ë˜: ${whaleTransaction.amount.toFixed(2)} BTC ($${(whaleTransaction.usdValue/1000000).toFixed(1)}M)`,
                            'info'
                        );
                    }
                }
            }
        });
    }

    extractFromAddress(tx) {
        // ì²« ë²ˆì§¸ ì…ë ¥ì˜ ì£¼ì†Œ ì¶”ì¶œ
        if (tx.vin && tx.vin[0] && tx.vin[0].prevout) {
            return tx.vin[0].prevout.scriptpubkey_address || 'Unknown';
        }
        return generateRandomAddress();
    }

    extractToAddress(tx) {
        // ê°€ì¥ í° ì¶œë ¥ì˜ ì£¼ì†Œ ì¶”ì¶œ
        if (tx.vout && tx.vout.length > 0) {
            const largestOutput = tx.vout.reduce((max, current) => 
                current.value > max.value ? current : max
            );
            return largestOutput.scriptpubkey_address || 'Unknown';
        }
        return generateRandomAddress();
    }
    
    // ê¸°ì¡´ processBitcoinTransactions í•¨ìˆ˜ëŠ” ìƒˆë¡œìš´ mempool.space API ë²„ì „ìœ¼ë¡œ ëŒ€ì²´ë¨
    
    startBitcoinSimulation() {
        console.log('ğŸ­ ë¹„íŠ¸ì½”ì¸ ê³ ë˜ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ ì‹œì‘');
        
        // ì‹œë®¬ë ˆì´ì…˜ ë©¤í’€ í†µê³„ ìƒì„±
        this.generateSimulatedMempoolStats();
        
        const generateSimulatedBtcTx = () => {
            if (!this.isTracking) return;
            
            // 5% í™•ë¥ ë¡œ ê³ ë˜ ê±°ë˜ ìƒì„± (ì‹¤ì œë³´ë‹¤ ë†’ì€ ë¹ˆë„)
            if (Math.random() < 0.05) {
                // í˜„ì‹¤ì ì¸ ê³ ë˜ ê±°ë˜ í¬ê¸° ë¶„í¬
                let btcAmount;
                const rand = Math.random();
                if (rand < 0.6) {
                    btcAmount = Math.random() * 100 + 50; // 50-150 BTC (60%)
                } else if (rand < 0.85) {
                    btcAmount = Math.random() * 200 + 150; // 150-350 BTC (25%)
                } else if (rand < 0.95) {
                    btcAmount = Math.random() * 500 + 350; // 350-850 BTC (10%)
                } else {
                    btcAmount = Math.random() * 1000 + 850; // 850-1850 BTC (5%)
                }
                
                const whaleTransaction = {
                    id: 'sim_btc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    hash: generateRandomHash(),
                    amount: btcAmount,
                    type: 'bitcoin',
                    timestamp: Date.now(),
                    fromAddress: generateRandomAddress(),
                    toAddress: generateRandomAddress(),
                    usdValue: btcAmount * 104000,
                    fee: Math.random() * 0.005 + 0.001, // 0.001-0.006 BTC ìˆ˜ìˆ˜ë£Œ
                    size: Math.floor(Math.random() * 300) + 200,
                    confirmed: Math.random() > 0.3, // 70% í™•ì •, 30% ë©¤í’€
                    blockHeight: Math.random() > 0.3 ? Math.floor(Math.random() * 1000) + 875000 : null
                };
                
                this.allTransactions.unshift(whaleTransaction);
                this.stats.btcCount++;
                this.stats.totalVolume += whaleTransaction.usdValue;
                
                if (this.allTransactions.length > 200) {
                    this.allTransactions = this.allTransactions.slice(0, 200);
                }
                
                this.updateTransactionDisplay();
                this.updateStats();
                
                // ë“±ê¸‰ë³„ ì•Œë¦¼ (ì‹¤ì œ APIì™€ ë™ì¼)
                if (whaleTransaction.usdValue > 50000000) {
                    this.showNotification(
                        `ğŸ‹ğŸ‹ğŸ‹ [ì‹œë®¬ë ˆì´ì…˜] ì´ˆëŒ€í˜• ê³ ë˜: ${whaleTransaction.amount.toFixed(2)} BTC ($${(whaleTransaction.usdValue/1000000).toFixed(0)}M)`,
                        'mega-whale'
                    );
                } else if (whaleTransaction.usdValue > 10000000) {
                    this.showNotification(
                        `ğŸ‹ğŸ‹ [ì‹œë®¬ë ˆì´ì…˜] ëŒ€í˜• ê³ ë˜: ${whaleTransaction.amount.toFixed(2)} BTC ($${(whaleTransaction.usdValue/1000000).toFixed(1)}M)`,
                        'whale'
                    );
                } else if (whaleTransaction.usdValue > 5000000) {
                    this.showNotification(
                        `ğŸ‹ [ì‹œë®¬ë ˆì´ì…˜] ì¤‘í˜• ê³ ë˜: ${whaleTransaction.amount.toFixed(2)} BTC ($${(whaleTransaction.usdValue/1000000).toFixed(1)}M)`,
                        'info'
                    );
                }
            }
            
            // 10-30ì´ˆ í›„ ë‹¤ì‹œ ì‹¤í–‰ (ë” ìì£¼)
            if (this.isTracking) {
                setTimeout(generateSimulatedBtcTx, Math.random() * 20000 + 10000);
            }
        };
        
        // ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘
        setTimeout(generateSimulatedBtcTx, 2000);
    }

    generateSimulatedMempoolStats() {
        // ì‹œë®¬ë ˆì´ì…˜ìš© ë©¤í’€ í†µê³„ ìƒì„±
        const simulatedMempoolInfo = {
            size: Math.floor(Math.random() * 50000) + 150000, // 150K-200K ê±°ë˜
            bytes: Math.floor(Math.random() * 50000000) + 100000000, // 100-150MB
            usage: Math.floor(Math.random() * 100000000) + 500000000
        };

        const simulatedFees = {
            fastestFee: Math.floor(Math.random() * 50) + 20, // 20-70 sat/vB
            halfHourFee: Math.floor(Math.random() * 30) + 15,
            hourFee: Math.floor(Math.random() * 20) + 10,
            economyFee: Math.floor(Math.random() * 10) + 5,
            minimumFee: Math.floor(Math.random() * 5) + 1
        };

        const vBytesPerSecond = Math.floor(Math.random() * 3000) + 1000; // 1000-4000 vB/s

        this.updateBitcoinMempoolStats(simulatedMempoolInfo, vBytesPerSecond, simulatedFees);

        // 30ì´ˆë§ˆë‹¤ ë©¤í’€ í†µê³„ ì—…ë°ì´íŠ¸
        if (this.isTracking) {
            setTimeout(() => this.generateSimulatedMempoolStats(), 30000);
        }
    }
    
    async startEthereumTracking() {
        if (!this.web3) {
            console.log('Web3 not available, starting simulation mode');
            this.startEthereumSimulation();
            return;
        }
        
        try {
            // HTTP ë°©ì‹ìœ¼ë¡œ í´ë§ (ê³µê°œ RPCëŠ” ëŒ€ë¶€ë¶„ HTTPë§Œ ì§€ì›)
            this.startEthereumPollingTracking();
            
        } catch (error) {
            console.error('Ethereum tracking error:', error);
            this.updateStatus('eth', 'error', 'ì¶”ì  ì˜¤ë¥˜');
            // ì‹¤íŒ¨ì‹œ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì „í™˜
            this.startEthereumSimulation();
        }
    }
    
    startEthereumSimulation() {
        console.log('Starting Ethereum simulation mode');
        this.updateStatus('eth', 'connected', 'ì‹œë®¬ë ˆì´ì…˜ ì¤‘...');
        
        const generateSimulatedEthTx = () => {
            if (!this.isTracking) return;
            
            // 5% í™•ë¥ ë¡œ ê³ ë˜ ê±°ë˜ ìƒì„±
            if (Math.random() < 0.05) {
                const ethAmount = Math.random() * 3000 + 1000; // 1000-4000 ETH
                
                const whaleTransaction = {
                    id: 'sim_eth_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    hash: '0x' + generateRandomHash(),
                    amount: ethAmount,
                    type: 'ethereum',
                    timestamp: Date.now(),
                    fromAddress: generateRandomAddress(),
                    toAddress: generateRandomAddress(),
                    usdValue: ethAmount * 3400,
                    gasPrice: Math.random() * 50 + 10
                };
                
                this.allTransactions.unshift(whaleTransaction);
                this.stats.ethCount++;
                this.stats.totalVolume += ethAmount * 3400;
                
                if (this.allTransactions.length > 200) {
                    this.allTransactions = this.allTransactions.slice(0, 200);
                }
                
                this.updateTransactionDisplay();
                this.updateStats();
                
                if (ethAmount >= this.ethThreshold * 2) {
                    this.showNotification(
                        `ğŸ‹ ì‹œë®¬ë ˆì´ì…˜: ëŒ€í˜• ì´ë”ë¦¬ì›€ ê±°ë˜ ${ethAmount.toFixed(2)} ETH`, 
                        'warning'
                    );
                }
            }
            
            // 10-30ì´ˆ í›„ ë‹¤ì‹œ ì‹¤í–‰
            if (this.isTracking) {
                setTimeout(generateSimulatedEthTx, Math.random() * 20000 + 10000);
            }
        };
        
        // ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘
        setTimeout(generateSimulatedEthTx, 5000);
    }
    
    async startEthereumWebSocketTracking() {
        try {
            const subscription = this.web3.eth.subscribe('newBlockHeaders');
            
            subscription.on('data', async (blockHeader) => {
                if (!this.isTracking) return;
                await this.processEthereumBlock(blockHeader.number);
            });
            
            subscription.on('error', (error) => {
                console.error('Ethereum subscription error:', error);
                this.updateStatus('eth', 'error', 'ì—°ê²° ì˜¤ë¥˜');
                // WebSocket ì‹¤íŒ¨ì‹œ í´ë§ìœ¼ë¡œ ì „í™˜
                this.startEthereumPollingTracking();
            });
            
        } catch (error) {
            console.error('WebSocket tracking failed:', error);
            this.startEthereumPollingTracking();
        }
    }
    
    async startEthereumPollingTracking() {
        let lastBlockNumber = 0n; // BigIntë¡œ ì´ˆê¸°í™”
        
        const pollBlocks = async () => {
            if (!this.isTracking) return;
            
            try {
                const currentBlockNumber = await this.web3.eth.getBlockNumber();
                const currentBlockBigInt = BigInt(currentBlockNumber);
                
                if (currentBlockBigInt > lastBlockNumber) {
                    // ìµœì‹  ë¸”ë¡ë§Œ ì²˜ë¦¬ (ë„ˆë¬´ ë§ì€ ë¸”ë¡ì„ ì²˜ë¦¬í•˜ì§€ ì•Šë„ë¡)
                    const blocksToProcess = Math.min(Number(currentBlockBigInt - lastBlockNumber), 5);
                    
                    for (let i = 0; i < blocksToProcess; i++) {
                        const blockNum = currentBlockBigInt - BigInt(blocksToProcess - 1 - i);
                        await this.processEthereumBlock(Number(blockNum));
                    }
                    lastBlockNumber = currentBlockBigInt;
                }
                
                this.updateStatus('eth', 'connected', 'HTTP í´ë§ ì¤‘...');
            } catch (error) {
                console.error('Polling error:', error);
                this.updateStatus('eth', 'error', 'í´ë§ ì˜¤ë¥˜');
                
                // 3ë²ˆ ì—°ì† ì‹¤íŒ¨ì‹œ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œë¡œ ì „í™˜
                if (!this.pollingErrorCount) this.pollingErrorCount = 0;
                this.pollingErrorCount++;
                
                if (this.pollingErrorCount >= 3) {
                    console.log('Too many polling errors, switching to simulation');
                    this.startEthereumSimulation();
                    return;
                }
            }
            
            // 15ì´ˆë§ˆë‹¤ í´ë§
            if (this.isTracking) {
                setTimeout(pollBlocks, 15000);
            }
        };
        
        // ì´ˆê¸° ë¸”ë¡ ë²ˆí˜¸ ì„¤ì •
        try {
            const initialBlock = await this.web3.eth.getBlockNumber();
            lastBlockNumber = BigInt(initialBlock);
            this.pollingErrorCount = 0;
            console.log(`Starting Ethereum polling from block: ${lastBlockNumber}`);
            pollBlocks();
        } catch (error) {
            console.error('Initial block number fetch failed:', error);
            this.startEthereumSimulation();
        }
    }
    
    async processEthereumBlock(blockNumber) {
        try {
            const block = await this.web3.eth.getBlock(blockNumber, true);
            
            if (block && block.transactions && Array.isArray(block.transactions)) {
                let processedCount = 0;
                
                for (const tx of block.transactions) {
                    if (tx && tx.value) {
                        try {
                            // BigInt ê°’ì„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
                            const txValue = typeof tx.value === 'bigint' ? tx.value.toString() : tx.value;
                            const ethAmount = this.web3.utils.fromWei(txValue, 'ether');
                            const ethAmountNum = parseFloat(ethAmount);
                            
                            if (ethAmountNum >= this.ethThreshold) {
                                // Gas price ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
                                let gasPriceGwei = 0;
                                if (tx.gasPrice) {
                                    try {
                                        const gasPrice = typeof tx.gasPrice === 'bigint' ? tx.gasPrice.toString() : tx.gasPrice;
                                        gasPriceGwei = parseFloat(this.web3.utils.fromWei(gasPrice, 'gwei'));
                                    } catch (gasPriceError) {
                                        console.log('Gas price conversion error:', gasPriceError);
                                    }
                                }
                                
                                const whaleTransaction = {
                                    id: tx.hash,
                                    hash: tx.hash,
                                    amount: ethAmountNum,
                                    type: 'ethereum',
                                    timestamp: Date.now(),
                                    from: tx.from || 'Unknown',
                                    to: tx.to || 'Unknown',
                                    gasPrice: gasPriceGwei
                                };
                                
                                // ì¤‘ë³µ ë°©ì§€
                                if (!this.ethTransactions.find(t => t.id === whaleTransaction.id)) {
                                    this.ethTransactions.unshift(whaleTransaction);
                                    this.stats.ethCount++;
                                    this.stats.totalVolume += ethAmountNum * 3000; // ì„ì‹œ ETH ê°€ê²©
                                    
                                    // ìµœëŒ€ 50ê°œ ê±°ë˜ë§Œ ìœ ì§€
                                    if (this.ethTransactions.length > 50) {
                                        this.ethTransactions = this.ethTransactions.slice(0, 50);
                                    }
                                    
                                    this.updateTransactionDisplay();
                                    this.updateStats();
                                    
                                    processedCount++;
                                    
                                    // í° ê±°ë˜ì— ëŒ€í•œ ì•Œë¦¼
                                    if (ethAmountNum >= this.ethThreshold * 2) {
                                        this.showNotification(
                                            `ğŸ‹ ëŒ€í˜• ì´ë”ë¦¬ì›€ ê±°ë˜ ê°ì§€: ${ethAmountNum.toFixed(2)} ETH`, 
                                            'warning'
                                        );
                                    }
                                }
                            }
                        } catch (txError) {
                            console.log('Transaction processing error:', txError);
                            continue;
                        }
                    }
                }
                
                if (processedCount > 0) {
                    console.log(`Processed ${processedCount} whale transactions from block ${blockNumber}`);
                }
            }
        } catch (error) {
            console.error(`Block ${blockNumber} processing error:`, error);
        }
    }
    
    updateWhaleDisplay() {
        // whale-transactions ì»¨í…Œì´ë„ˆê°€ ì—†ìœ¼ë©´ í•¨ìˆ˜ ì¢…ë£Œ
        const container = document.getElementById('whale-transactions');
        if (!container) {
            console.log('ğŸ“ whale-transactions ì»¨í…Œì´ë„ˆê°€ ì—†ì–´ì„œ í‘œì‹œë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.');
            return;
        }

        const loadMoreBtn = document.getElementById('load-more');
        
        // í•„í„°ë§ëœ ê±°ë˜ë“¤
        let filteredTransactions = this.allTransactions;
        if (this.currentFilter !== 'all') {
            filteredTransactions = this.allTransactions.filter(tx => tx.type === this.currentFilter);
        }
        
        if (filteredTransactions.length === 0) {
            container.innerHTML = `
                <div class="no-whale-data">
                    <i class="fas fa-search"></i>
                    <p>ì¶”ì ì„ ì‹œì‘í•˜ë©´ ê³ ë˜ ê±°ë˜ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
                </div>
            `;
            if (loadMoreBtn) {
                loadMoreBtn.style.display = 'none';
            }
            return;
        }
        
        // í‘œì‹œí•  ê±°ë˜ë“¤ (displayedCount ê°œìˆ˜ë§Œí¼)
        const displayTransactions = filteredTransactions.slice(0, this.displayedCount);
        
        container.innerHTML = displayTransactions.map(tx => this.createTransactionHTML(tx)).join('');
        
        // Load More ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
        if (loadMoreBtn) {
            if (filteredTransactions.length > this.displayedCount) {
                loadMoreBtn.style.display = 'block';
            } else {
                loadMoreBtn.style.display = 'none';
            }
        }
    }

    // ===== ì‹¤ì‹œê°„ ê±°ë˜ ê¸°ëŠ¥ =====
    startRealtimeTracking() {
        this.generateRealtimeTrades();
        
        if (this.intervals.realtime) return;
        
        this.intervals.realtime = setInterval(() => {
            if (!this.realtimePaused && this.isTracking) {
                this.addRealtimeTrade();
            }
        }, 500); // 500msë§ˆë‹¤ ìƒˆ ê±°ë˜ ì¶”ê°€
    }

    generateRealtimeTrades() {
        const tradesContainer = document.getElementById('trades-list');
        if (!tradesContainer) return;

        this.realtimeTrades = [];
        
        for (let i = 0; i < 20; i++) {
            this.addRealtimeTrade(false);
        }
        
        this.updateRealtimeDisplay();
        this.updateRealtimeStats();
    }

    addRealtimeTrade(updateDisplay = true) {
        const symbols = ['BTCUSDT', 'ETHUSDT', 'ADAUSDT'];
        const symbol = this.realtimeSymbol || symbols[Math.floor(Math.random() * symbols.length)];
        
        const basePrice = symbol === 'BTCUSDT' ? 104000 : symbol === 'ETHUSDT' ? 3400 : 2.5;
        const price = basePrice * (1 + (Math.random() - 0.5) * 0.02);
        const quantity = Math.random() * 10 + 0.1;
        const isBuy = Math.random() > 0.5;
        
        const trade = {
            time: new Date().toLocaleTimeString(),
            price: price.toFixed(symbol === 'ADAUSDT' ? 4 : 2),
            quantity: quantity.toFixed(4),
            type: isBuy ? 'buy' : 'sell',
            timestamp: Date.now()
        };

        this.realtimeTrades.unshift(trade);
        
        // ìµœëŒ€ 100ê°œ ê±°ë˜ë§Œ ìœ ì§€
        if (this.realtimeTrades.length > 100) {
            this.realtimeTrades = this.realtimeTrades.slice(0, 100);
        }

        if (updateDisplay) {
            this.updateRealtimeDisplay();
            this.updateRealtimeStats();
        }
    }

    updateRealtimeDisplay() {
        const container = document.getElementById('trades-list');
        if (!container) return;

        const displayTrades = this.realtimeTrades.slice(0, 50);
        
        container.innerHTML = `
            <div class="trade-header-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 1rem; padding: 0.8rem 1rem; border-bottom: 2px solid #374151; font-weight: 600; color: #9ca3af; margin-bottom: 0.5rem; background: #111827;">
                <span>ì‹œê°„</span>
                <span>ê°€ê²©</span>
                <span>ìˆ˜ëŸ‰</span>
                <span>ìœ í˜•</span>
            </div>
            ${displayTrades.map(trade => `
                <div class="trade-item">
                    <span class="trade-time">${trade.time}</span>
                    <span class="trade-price">$${trade.price}</span>
                    <span class="trade-quantity">${trade.quantity}</span>
                    <span class="trade-type ${trade.type}">${trade.type.toUpperCase()}</span>
                </div>
            `).join('')}
        `;
    }

    updateRealtimeStats() {
        const currentPrice = this.realtimeTrades.length > 0 ? this.realtimeTrades[0].price : '0';
        const priceChange = (Math.random() - 0.5) * 10;
        const volume = Math.random() * 1000000 + 500000;

        document.getElementById('current-price').textContent = '$' + currentPrice;
        
        const changeElement = document.getElementById('price-change');
        changeElement.textContent = (priceChange >= 0 ? '+' : '') + priceChange.toFixed(2) + '%';
        changeElement.style.color = priceChange >= 0 ? '#10b981' : '#ef4444';
        
        document.getElementById('volume-24h').textContent = (volume / 1000).toFixed(0) + 'K';
    }

    toggleRealtimeTracking() {
        this.realtimePaused = !this.realtimePaused;
        const btn = document.getElementById('realtime-toggle');
        if (btn) {
            btn.innerHTML = this.realtimePaused ? 
                '<i class="fas fa-play"></i> ì¬ê°œ' : 
                '<i class="fas fa-pause"></i> ì¼ì‹œì •ì§€';
        }
    }

    // ===== ê¸°ìˆ ì§€í‘œ ê¸°ëŠ¥ =====
    updateIndicators(symbol = 'BTCUSDT') {
        // RSI ê³„ì‚° (ì‹œë®¬ë ˆì´ì…˜)
        const rsi = Math.random() * 100;
        this.indicators.rsi = rsi;
        
        document.getElementById('rsi-value').textContent = rsi.toFixed(1);
        document.getElementById('rsi-fill').style.width = rsi + '%';
        
        let rsiStatus = 'ì¤‘ë¦½';
        if (rsi > 70) rsiStatus = 'ê³¼ë§¤ìˆ˜';
        else if (rsi < 30) rsiStatus = 'ê³¼ë§¤ë„';
        document.getElementById('rsi-status').textContent = rsiStatus;

        // MACD
        const macd = (Math.random() - 0.5) * 1000;
        this.indicators.macd = macd;
        document.getElementById('macd-value').textContent = macd.toFixed(2);
        document.getElementById('macd-status').textContent = macd > 0 ? 'ê°•ì„¸' : 'ì•½ì„¸';

        // ë³¼ë¦°ì € ë°´ë“œ
        const bbPosition = ['ìƒë‹¨', 'ì¤‘ê°„', 'í•˜ë‹¨'][Math.floor(Math.random() * 3)];
        document.getElementById('bb-position').textContent = bbPosition;
        document.getElementById('bb-status').textContent = bbPosition === 'ì¤‘ê°„' ? 'ì •ìƒ' : 'ì£¼ì˜';

        // ìŠ¤í† ìºìŠ¤í‹±
        const stoch = Math.random() * 100;
        this.indicators.stoch = stoch;
        document.getElementById('stoch-value').textContent = stoch.toFixed(1);
        
        let stochStatus = 'ì¤‘ë¦½';
        if (stoch > 80) stochStatus = 'ê³¼ë§¤ìˆ˜';
        else if (stoch < 20) stochStatus = 'ê³¼ë§¤ë„';
        document.getElementById('stoch-status').textContent = stochStatus;
    }

    initializeIndicatorCharts() {
        const canvas = document.getElementById('indicators-chart');
        if (!canvas) return;

        // ê°€ê²© ì°¨íŠ¸ì™€ ì§€í‘œë“¤ì„ í•¨ê»˜ í‘œì‹œ
        this.charts.indicators = new Chart(canvas, {
            type: 'line',
            data: {
                labels: Array.from({length: 50}, (_, i) => i),
                datasets: [{
                    label: 'ê°€ê²©',
                    data: Array.from({length: 50}, () => Math.random() * 1000 + 30000),
                    borderColor: 'rgb(59, 130, 246)',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    yAxisID: 'y'
                }, {
                    label: 'RSI',
                    data: Array.from({length: 50}, () => Math.random() * 100),
                    borderColor: 'rgb(245, 158, 11)',
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    yAxisID: 'y1'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        ticks: {
                            color: '#9ca3af'
                        },
                        grid: {
                            color: '#374151'
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        max: 100,
                        min: 0,
                        ticks: {
                            color: '#9ca3af'
                        },
                        grid: {
                            drawOnChartArea: false,
                            color: '#374151'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#9ca3af'
                        },
                        grid: {
                            color: '#374151'
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#ffffff'
                        }
                    }
                }
            }
        });
    }

    startIndicatorTracking() {
        if (this.intervals.indicators) return;
        
        this.intervals.indicators = setInterval(() => {
            if (this.isTracking) {
                this.updateIndicators();
            }
        }, 3000); // 3ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
    }
    
    createTransactionHTML(tx) {
        const whaleLevel = this.getWhaleLevel(tx.type, tx.amount);
        const whaleEmojis = 'ğŸ‹'.repeat(whaleLevel);
        const exchangeName = this.getExchangeName(tx.fromAddress) || this.getExchangeName(tx.toAddress);
        const timeAgo = this.getTimeAgo(tx.timestamp);
        
        // USD ê°€ì¹˜ ê³„ì‚° (ì‹œë®¬ë ˆì´ì…˜ìš©)
        let usdValue = tx.usdValue;
        if (!usdValue) {
            if (tx.type === 'bitcoin') {
                usdValue = tx.amount * 104000; // ëŒ€ëµì ì¸ BTC ê°€ê²©
            } else {
                usdValue = tx.amount * 3400; // ëŒ€ëµì ì¸ ETH ê°€ê²©
            }
        }
        
        const fromDisplay = this.formatAddress(tx.fromAddress);
        const toDisplay = this.formatAddress(tx.toAddress);
        
        // ê±°ë˜ ìƒíƒœ ê²°ì •
        const isMempool = tx.isMempool || tx.confirmed === false;
        const statusBadge = isMempool ? 
            '<span class="mempool-badge">ğŸ“¡ ë©¤í’€</span>' : 
            `<span class="confirmed-badge">âœ… í™•ì • ${tx.blockHeight ? `#${tx.blockHeight}` : ''}</span>`;
        
        // ê³ ë˜ í¬ê¸° ì„¤ëª…
        const whaleSize = this.getWhaleSizeDescription(tx.type, tx.amount);
        const whaleDescription = this.getWhaleDescription(usdValue);
        
        // ì§€ê°‘ ìœ í˜• ì„¤ëª…
        const fromWalletType = this.getWalletTypeDescription(tx.fromAddress);
        const toWalletType = this.getWalletTypeDescription(tx.toAddress);
        
        return `
            <div class="whale-transaction-item ${isMempool ? 'mempool' : 'confirmed'}">
                <div class="whale-header">
                    <div class="crypto-icon ${tx.type}">
                        ${tx.type === 'bitcoin' ? 'â‚¿' : 'Î'}
                    </div>
                    <div class="whale-grade">
                        <div class="whale-level">${whaleEmojis}</div>
                        <span class="whale-size">${whaleSize}</span>
                    </div>
                    <div class="transaction-time">${timeAgo}</div>
                </div>
                
                <div class="transaction-main-info">
                    <div class="amount-section">
                        <div class="amount-display">
                            <span class="amount-number">${tx.amount.toLocaleString()}</span>
                            <span class="amount-currency">${tx.type === 'bitcoin' ? 'BTC' : 'ETH'}</span>
                        </div>
                        <div class="amount-usd">â‰ˆ $${(usdValue/1000000).toFixed(1)}M USD</div>
                        <div class="whale-explanation">${whaleDescription}</div>
                        ${statusBadge}
                    </div>
                    
                    <div class="transfer-section">
                        <div class="transfer-title">ğŸ’° ìê¸ˆ ì´ë™ í˜„í™©</div>
                        <div class="wallet-flow">
                            <div class="wallet-from">
                                <div class="wallet-label">ë³´ë‚¸ ê³³</div>
                                <div class="wallet-type">${fromWalletType}</div>
                                <div class="wallet-address">${fromDisplay}</div>
                            </div>
                            <div class="transfer-arrow">
                                <i class="fas fa-arrow-right"></i>
                            </div>
                            <div class="wallet-to">
                                <div class="wallet-label">ë°›ëŠ” ê³³</div>
                                <div class="wallet-type">${toWalletType}</div>
                                <div class="wallet-address">${toDisplay}</div>
                            </div>
                        </div>
                    </div>
                    
                    ${tx.fee ? `
                    <div class="transaction-details">
                        <div class="detail-item">
                            <span class="detail-label">ğŸ’¸ ë„¤íŠ¸ì›Œí¬ ìˆ˜ìˆ˜ë£Œ:</span>
                            <span class="detail-value">${tx.fee.toFixed(6)} ${tx.type === 'bitcoin' ? 'BTC' : 'ETH'} (ì•½ $${(tx.fee * (tx.type === 'bitcoin' ? 104000 : 3400)).toFixed(0)})</span>
                        </div>
                        ${tx.size ? `
                        <div class="detail-item">
                            <span class="detail-label">ğŸ“¦ ê±°ë˜ í¬ê¸°:</span>
                            <span class="detail-value">${(tx.size/1024).toFixed(1)} KB</span>
                        </div>
                        ` : ''}
                        ${tx.txCount ? `
                        <div class="detail-item">
                            <span class="detail-label">ğŸ“Š í¬í•¨ëœ ê±°ë˜:</span>
                            <span class="detail-value">${tx.txCount.toLocaleString()}ê°œ</span>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}
                </div>
            </div>
        `;
    }
    
    getWhaleLevel(type, amount) {
        if (type === 'bitcoin') {
            if (amount >= 1000) return 10;
            if (amount >= 500) return 8;
            if (amount >= 200) return 6;
            if (amount >= 100) return 4;
            return 3;
        } else { // ethereum
            if (amount >= 10000) return 10;
            if (amount >= 5000) return 8;
            if (amount >= 3000) return 6;
            if (amount >= 2000) return 4;
            return 3;
        }
    }

    getWhaleSizeDescription(type, amount) {
        if (type === 'bitcoin') {
            if (amount >= 1000) return 'ğŸ‹ğŸ‹ğŸ‹ ìŠˆí¼ ê³ ë˜ (Ultra Whale)';
            if (amount >= 500) return 'ğŸ‹ğŸ‹ ë©”ê°€ ê³ ë˜ (Mega Whale)';
            if (amount >= 200) return 'ğŸ‹ ëŒ€í˜• ê³ ë˜ (Large Whale)';
            if (amount >= 100) return 'ğŸ‹ ì¤‘í˜• ê³ ë˜ (Medium Whale)';
            return 'ğŸ‹ ì†Œí˜• ê³ ë˜ (Small Whale)';
        } else {
            if (amount >= 10000) return 'ğŸ‹ğŸ‹ğŸ‹ ìŠˆí¼ ê³ ë˜ (Ultra Whale)';
            if (amount >= 5000) return 'ğŸ‹ğŸ‹ ë©”ê°€ ê³ ë˜ (Mega Whale)';
            if (amount >= 3000) return 'ğŸ‹ ëŒ€í˜• ê³ ë˜ (Large Whale)';
            if (amount >= 2000) return 'ğŸ‹ ì¤‘í˜• ê³ ë˜ (Medium Whale)';
            return 'ğŸ‹ ì†Œí˜• ê³ ë˜ (Small Whale)';
        }
    }

    getWhaleDescription(usdValue) {
        if (usdValue >= 100000000) {
            return 'ğŸš¨ ì´ˆê±°ëŒ€ ìê¸ˆ ì´ë™! ì‹œì¥ì— í° ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆëŠ” ê·œëª¨ì…ë‹ˆë‹¤.';
        } else if (usdValue >= 50000000) {
            return 'âš¡ ëŒ€ê·œëª¨ ìê¸ˆ ì´ë™! ê¸°ê´€íˆ¬ìì ë˜ëŠ” ê³ ì•¡ìì‚°ê°€ì˜ ê±°ë˜ë¡œ ì¶”ì •ë©ë‹ˆë‹¤.';
        } else if (usdValue >= 10000000) {
            return 'ğŸ“ˆ ìƒë‹¹í•œ ê·œëª¨ì˜ ê±°ë˜ì…ë‹ˆë‹¤. ê°€ê²© ë³€ë™ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤.';
        } else if (usdValue >= 5000000) {
            return 'ğŸ’¼ ì¤‘ê·œëª¨ ê³ ë˜ ê±°ë˜ì…ë‹ˆë‹¤. ì‹œì¥ ë™í–¥ì„ ì£¼ì‹œí•˜ì„¸ìš”.';
        } else {
            return 'ğŸ¦ ì†Œê·œëª¨ ê³ ë˜ ê±°ë˜ì…ë‹ˆë‹¤. ì¼ë°˜ì ì¸ ëŒ€í˜• ê±°ë˜ ë²”ì£¼ì…ë‹ˆë‹¤.';
        }
    }

    getWalletTypeDescription(address) {
        if (!address) return 'ğŸ” ì•Œ ìˆ˜ ì—†ëŠ” ì§€ê°‘';
        
        const exchangeName = this.getExchangeName(address);
        if (exchangeName) {
            return `ğŸ¢ ${exchangeName} ê±°ë˜ì†Œ`;
        }
        
        // íŠ¹ì • íŒ¨í„´ìœ¼ë¡œ ì§€ê°‘ ìœ í˜• ì¶”ì •
        if (address.includes('Multiple')) {
            return 'ğŸ“¦ ë³µìˆ˜ ì…ë ¥ ê±°ë˜';
        } else if (address.length > 40) {
            return 'ğŸ‘¤ ê°œì¸ ì§€ê°‘ (Private Wallet)';
        } else if (address.startsWith('bc1') || address.startsWith('3')) {
            return 'ğŸ”’ ê°œì¸ ì§€ê°‘ (Bitcoin Address)';
        } else if (address.startsWith('0x')) {
            return 'ğŸ’ ê°œì¸ ì§€ê°‘ (Ethereum Address)';
        } else {
            return 'ğŸ“± ê°œì¸ ì§€ê°‘ (Private Wallet)';
        }
    }
    
    getExchangeName(address) {
        if (!address || !this.exchangeNames) return 'Unknown';
        return this.exchangeNames[address.toLowerCase()] || 'Unknown';
    }
    
    formatAddress(address) {
        if (!address) return 'unknown wallet';
        if (this.getExchangeName(address)) return this.getExchangeName(address);
        return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
    }
    
    getTimeAgo(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);
        
        if (minutes < 1) return 'ë°©ê¸ˆ ì „';
        if (minutes < 60) return `${minutes}ë¶„ ì „`;
        if (hours < 24) return `${hours}ì‹œê°„ ì „`;
        return `${days} ì¼ì „`;
    }
    
    loadMoreTransactions() {
        this.displayedCount += 20;
        this.updateTransactionDisplay();
    }
    
    refreshData() {
        const btn = document.getElementById('refresh-data');
        btn.style.transform = 'rotate(360deg)';
        setTimeout(() => {
            btn.style.transform = 'rotate(0deg)';
        }, 500);
        
        this.updateTransactionDisplay();
        this.updateStats();
    }
    
    updateStats() {
        // ê¸°ì¡´ í†µê³„ ì—…ë°ì´íŠ¸ (í•˜ìœ„ í˜¸í™˜ì„±)
        const btcElement = document.getElementById('btc-total-transactions');
        const ethElement = document.getElementById('eth-total-transactions');
        const volumeElement = document.getElementById('total-volume');
        
        if (btcElement) btcElement.textContent = this.stats.btcCount;
        if (ethElement) ethElement.textContent = this.stats.ethCount;
        if (volumeElement) volumeElement.textContent = `$${this.stats.totalVolume.toLocaleString()}`;
        
        // ìƒˆë¡œìš´ í—¤ë” í†µê³„ ì—…ë°ì´íŠ¸
        this.updateHeaderStats();
    }

    updateHeaderStats() {
        const headerBtc = document.getElementById('header-btc-count');
        const headerEth = document.getElementById('header-eth-count');
        const headerVolume = document.getElementById('header-total-volume');
        
        if (headerBtc) headerBtc.textContent = this.stats.btcCount.toLocaleString();
        if (headerEth) headerEth.textContent = this.stats.ethCount.toLocaleString();
        if (headerVolume) {
            const volume = this.stats.totalVolume;
            if (volume >= 1000000000) {
                headerVolume.textContent = `$${(volume / 1000000000).toFixed(1)}B`;
            } else if (volume >= 1000000) {
                headerVolume.textContent = `$${(volume / 1000000).toFixed(1)}M`;
            } else if (volume >= 1000) {
                headerVolume.textContent = `$${(volume / 1000).toFixed(1)}K`;
            } else {
                headerVolume.textContent = `$${volume.toFixed(0)}`;
            }
        }
    }
    
    updateLastUpdateTime() {
        const now = new Date();
        document.getElementById('last-update').textContent = now.toLocaleTimeString();
    }
    
    switchTab(tabName) {
        // íƒ­ ë²„íŠ¼ ì—…ë°ì´íŠ¸
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
        
        // íƒ­ íŒ¨ë„ ì—…ë°ì´íŠ¸
        document.querySelectorAll('.tab-panel').forEach(panel => {
            panel.classList.remove('active');
        });
        document.getElementById(`${tabName}-panel`).classList.add('active');
    }
    
    clearTransactions() {
        this.allTransactions = [];
        this.stats.btcCount = 0;
        this.stats.ethCount = 0;
        this.stats.totalVolume = 0;
        this.displayedCount = 20;
        
        this.updateTransactionDisplay();
        this.updateStats();
        this.showNotification('ëª¨ë“  ê±°ë˜ ê¸°ë¡ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
    }
    
    updateStatus(coin, status, text) {
        const statusElement = document.getElementById(`${coin}-status`);
        if (!statusElement) {
            console.log(`Status element not found: ${coin}-status`);
            return;
        }
        
        const dot = statusElement.querySelector('.status-dot');
        const textElement = statusElement.querySelector('.status-text');
        
        if (dot && textElement) {
            // ê¸°ì¡´ í´ë˜ìŠ¤ ì œê±°
            dot.classList.remove('connecting', 'connected', 'error');
            dot.classList.add(status);
            textElement.textContent = text;
        }
    }
    
    formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }
    
    showNotification(message, type = 'info') {
        // ê°„ë‹¨í•œ í† ìŠ¤íŠ¸ ì•Œë¦¼ ìƒì„±
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'warning' ? 'exclamation-triangle' : 'info-circle'}"></i>
            <span>${message}</span>
        `;
        
        // ìŠ¤íƒ€ì¼ ì¶”ê°€
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'success' ? '#4CAF50' : type === 'warning' ? '#ff9800' : '#2196F3'};
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        `;
        
        document.body.appendChild(notification);
        
        // ì• ë‹ˆë©”ì´ì…˜
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 100);
        
        // ìë™ ì œê±°
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    // ===== ì²­ì‚° ì •ë³´ ê¸°ëŠ¥ =====
    initializeLiquidationChart() {
        const canvas = document.getElementById('liquidation-chart');
        if (!canvas) return;

        this.charts.liquidation = new Chart(canvas, {
            type: 'bar',
            data: {
                labels: ['1ì‹œê°„', '2ì‹œê°„', '3ì‹œê°„', '4ì‹œê°„', '5ì‹œê°„', '6ì‹œê°„'],
                datasets: [{
                    label: 'ë¡± ì²­ì‚°',
                    data: [12000000, 8500000, 15000000, 9800000, 11200000, 13400000],
                    backgroundColor: 'rgba(16, 185, 129, 0.8)',
                }, {
                    label: 'ìˆ ì²­ì‚°',
                    data: [8000000, 12000000, 7500000, 14000000, 9600000, 10800000],
                    backgroundColor: 'rgba(239, 68, 68, 0.8)',
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            color: '#9ca3af',
                            callback: function(value) {
                                return '$' + (value / 1000000).toFixed(1) + 'M';
                            }
                        },
                        grid: {
                            color: '#374151'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#9ca3af'
                        },
                        grid: {
                            color: '#374151'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        labels: {
                            color: '#ffffff'
                        }
                    }
                }
            }
        });
    }

    updateLiquidationData(exchange = 'all') {
        // ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„° ìƒì„±
        const longLiquidation = Math.random() * 50000000 + 10000000; // 10-60M
        const shortLiquidation = Math.random() * 40000000 + 15000000; // 15-55M
        
        this.liquidationData.long.amount = longLiquidation;
        this.liquidationData.short.amount = shortLiquidation;
        this.liquidationData.long.count = Math.floor(Math.random() * 500) + 100;
        this.liquidationData.short.count = Math.floor(Math.random() * 400) + 120;

        // UI ì—…ë°ì´íŠ¸
        document.getElementById('long-liquidation').textContent = '$' + (longLiquidation / 1000000).toFixed(1) + 'M';
        document.getElementById('short-liquidation').textContent = '$' + (shortLiquidation / 1000000).toFixed(1) + 'M';
        document.getElementById('long-count').textContent = this.liquidationData.long.count + 'ê±´';
        document.getElementById('short-count').textContent = this.liquidationData.short.count + 'ê±´';

        this.updateLiquidationList();
    }

    updateLiquidationList() {
        const container = document.getElementById('liquidation-list');
        if (!container) return;

        const liquidations = [];
        for (let i = 0; i < 20; i++) {
            liquidations.push({
                symbol: ['BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'SOLUSDT'][Math.floor(Math.random() * 4)],
                side: Math.random() > 0.5 ? 'Long' : 'Short',
                amount: Math.random() * 1000000 + 100000,
                price: Math.random() * 100000 + 30000,
                time: new Date(Date.now() - Math.random() * 3600000).toLocaleTimeString()
            });
        }

        container.innerHTML = `
            <div class="liquidation-header-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap: 1rem; padding: 0.8rem 0; border-bottom: 2px solid #374151; font-weight: 600; color: #9ca3af; margin-bottom: 0.5rem;">
                <span>ì‹¬ë³¼</span>
                <span>ë°©í–¥</span>
                <span>ê¸ˆì•¡</span>
                <span>ê°€ê²©</span>
                <span>ì‹œê°„</span>
            </div>
            ${liquidations.map(liq => `
                <div class="liquidation-item">
                    <span class="liq-symbol">${liq.symbol}</span>
                    <span class="liq-side ${liq.side.toLowerCase()}">${liq.side}</span>
                    <span class="liq-amount">$${(liq.amount / 1000).toFixed(0)}K</span>
                    <span class="liq-price">$${liq.price.toFixed(2)}</span>
                    <span class="liq-time">${liq.time}</span>
                </div>
            `).join('')}
        `;
    }

    startLiquidationTracking() {
        if (this.intervals.liquidation) return;
        
        this.intervals.liquidation = setInterval(() => {
            if (this.isTracking) {
                this.updateLiquidationData();
            }
        }, 10000); // 10ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
    }

    // ===== ë¡±ìˆ ë¹„ìœ¨ ê¸°ëŠ¥ =====
    initializeLongShortChart() {
        const canvas = document.getElementById('longsshorts-chart');
        if (!canvas) return;

        this.charts.longshort = new Chart(canvas, {
            type: 'line',
            data: {
                labels: Array.from({length: 24}, (_, i) => `${i}:00`),
                datasets: [{
                    label: 'ë¡± ë¹„ìœ¨',
                    data: Array.from({length: 24}, () => Math.random() * 30 + 45),
                    borderColor: 'rgb(16, 185, 129)',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    tension: 0.4
                }, {
                    label: 'ìˆ ë¹„ìœ¨',
                    data: Array.from({length: 24}, () => Math.random() * 30 + 25),
                    borderColor: 'rgb(239, 68, 68)',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            color: '#9ca3af',
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        grid: {
                            color: '#374151'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#9ca3af'
                        },
                        grid: {
                            color: '#374151'
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#ffffff'
                        }
                    }
                }
            }
        });
    }

    updateLongShortDisplay() {
        const longPercent = Math.random() * 30 + 45; // 45-75%
        const shortPercent = 100 - longPercent;

        document.getElementById('long-percentage').textContent = longPercent.toFixed(1) + '%';
        document.getElementById('short-percentage').textContent = shortPercent.toFixed(1) + '%';

        // ê±°ë˜ì†Œë³„ ì—…ë°ì´íŠ¸
        this.updateExchangeRatios();
    }

    updateExchangeRatios() {
        const exchanges = ['binance', 'okx'];
        exchanges.forEach(exchange => {
            const longPercent = Math.random() * 20 + 50; // 50-70%
            const shortPercent = 100 - longPercent;

            const longBar = document.getElementById(`${exchange}-long`);
            const shortBar = document.getElementById(`${exchange}-short`);
            const card = longBar?.closest('.exchange-ratio-card');

            if (longBar && shortBar && card) {
                longBar.style.width = longPercent + '%';
                shortBar.style.width = shortPercent + '%';

                const longNum = card.querySelector('.long-num');
                const shortNum = card.querySelector('.short-num');
                if (longNum) longNum.textContent = longPercent.toFixed(0) + '%';
                if (shortNum) shortNum.textContent = shortPercent.toFixed(0) + '%';
            }
        });
    }

    startLongShortTracking() {
        if (this.intervals.longshort) return;
        
        this.intervals.longshort = setInterval(() => {
            if (this.isTracking) {
                this.updateLongShortDisplay();
            }
        }, 5000); // 5ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
    }

    updateUI() {
        this.updateWhaleDisplay();
        this.updateStats();
        this.updateLastUpdateTime();
    }

    // ===== Fear & Greed Index ê¸°ëŠ¥ =====
    updateFearGreedIndex() {
        const value = Math.floor(Math.random() * 100);
        this.fearGreedIndex.value = value;
        
        let label = '';
        if (value <= 25) label = 'ê·¹ë‹¨ì  ê³µí¬';
        else if (value <= 45) label = 'ê³µí¬';
        else if (value <= 55) label = 'ì¤‘ë¦½';
        else if (value <= 75) label = 'íƒìš•';
        else label = 'ê·¹ë‹¨ì  íƒìš•';
        
        this.fearGreedIndex.label = label;

        try {
            // UI ì—…ë°ì´íŠ¸ with correct element IDs
            const sentimentValue = document.getElementById('sentiment-value');
            const sentimentLabel = document.getElementById('sentiment-label');
            
            if (sentimentValue) sentimentValue.textContent = value;
            if (sentimentLabel) sentimentLabel.textContent = label;

            // Update gauge if available
            const canvas = document.getElementById('fear-greed-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                this.drawFearGreedGauge(ctx, value);
            }
        } catch (error) {
            console.warn('Error updating Fear & Greed Index display:', error);
        }
    }

    initializeFearGreedGauge() {
        const canvas = document.getElementById('fear-greed-gauge');
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        this.drawFearGreedGauge(ctx, this.fearGreedIndex.value);
    }

    drawFearGreedGauge(ctx, value) {
        const centerX = 150;
        const centerY = 120;
        const radius = 80;

        // ë°°ê²½ í˜¸
        ctx.lineWidth = 15;
        ctx.strokeStyle = '#374151';
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, Math.PI, 2 * Math.PI);
        ctx.stroke();

        // ê·¸ë¼ë””ì–¸íŠ¸ í˜¸
        const gradient = ctx.createLinearGradient(centerX - radius, centerY, centerX + radius, centerY);
        gradient.addColorStop(0, '#dc2626');
        gradient.addColorStop(0.25, '#f59e0b');
        gradient.addColorStop(0.5, '#6b7280');
        gradient.addColorStop(0.75, '#10b981');
        gradient.addColorStop(1, '#059669');

        ctx.strokeStyle = gradient;
        ctx.beginPath();
        const angle = Math.PI + (value / 100) * Math.PI;
        ctx.arc(centerX, centerY, radius, Math.PI, angle);
        ctx.stroke();

        // í¬ì¸í„°
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(angle - Math.PI / 2);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-2, -radius - 10, 4, 20);
        ctx.restore();
    }

    initializeSentimentChart() {
        const canvas = document.getElementById('sentiment-chart');
        if (!canvas) return;

        const historyData = Array.from({length: 30}, () => Math.floor(Math.random() * 100));
        
        this.charts.sentiment = new Chart(canvas, {
            type: 'line',
            data: {
                labels: Array.from({length: 30}, (_, i) => i + 1),
                datasets: [{
                    label: 'Fear & Greed Index',
                    data: historyData,
                    borderColor: '#f59e0b',
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        min: 0,
                        max: 100,
                        ticks: {
                            color: '#9ca3af',
                            callback: function(value) {
                                if (value <= 25) return 'ê·¹ë‹¨ì  ê³µí¬';
                                if (value <= 45) return 'ê³µí¬';
                                if (value <= 55) return 'ì¤‘ë¦½';
                                if (value <= 75) return 'íƒìš•';
                                return 'ê·¹ë‹¨ì  íƒìš•';
                            }
                        },
                        grid: {
                            color: '#374151'
                        }
                    },
                    x: {
                        ticks: {
                            color: '#9ca3af'
                        },
                        grid: {
                            color: '#374151'
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#ffffff'
                        }
                    }
                }
            }
        });
    }

    startSentimentTracking() {
        if (this.intervals.sentiment) return;
        
        this.intervals.sentiment = setInterval(() => {
            if (this.isTracking) {
                this.updateFearGreedIndex();
                if (this.charts.sentiment) {
                    const newValue = Math.floor(Math.random() * 100);
                    this.charts.sentiment.data.datasets[0].data.push(newValue);
                    this.charts.sentiment.data.datasets[0].data.shift();
                    this.charts.sentiment.update('none');
                }
            }
        }, 30000);
    }

    // ===== íˆíŠ¸ë§µ ê¸°ëŠ¥ =====
    generateHeatmap() {
        const container = document.getElementById('heatmap-container');
        if (!container) return;

        const coins = [
            { name: 'BTC', change: (Math.random() - 0.5) * 20, size: 100 },
            { name: 'ETH', change: (Math.random() - 0.5) * 25, size: 80 },
            { name: 'ADA', change: (Math.random() - 0.5) * 30, size: 40 },
            { name: 'SOL', change: (Math.random() - 0.5) * 35, size: 35 },
            { name: 'DOT', change: (Math.random() - 0.5) * 25, size: 30 },
            { name: 'AVAX', change: (Math.random() - 0.5) * 40, size: 25 },
            { name: 'LINK', change: (Math.random() - 0.5) * 30, size: 20 },
            { name: 'UNI', change: (Math.random() - 0.5) * 35, size: 18 },
            { name: 'MATIC', change: (Math.random() - 0.5) * 40, size: 15 },
            { name: 'ATOM', change: (Math.random() - 0.5) * 30, size: 12 }
        ];

        container.innerHTML = `
            <div class="heatmap-grid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; padding: 20px;">
                ${coins.map(coin => {
                    const color = coin.change > 0 ? 
                        `rgba(16, 185, 129, ${Math.abs(coin.change) / 20})` : 
                        `rgba(239, 68, 68, ${Math.abs(coin.change) / 20})`;
                    
                    return `
                        <div class="heatmap-item" style="
                            background: ${color};
                            padding: 15px;
                            border-radius: 8px;
                            text-align: center;
                            color: white;
                            font-weight: 600;
                            min-height: ${coin.size}px;
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                        ">
                            <div style="font-size: 1.2rem;">${coin.name}</div>
                            <div style="font-size: 0.9rem; margin-top: 5px;">
                                ${coin.change >= 0 ? '+' : ''}${coin.change.toFixed(2)}%
                            </div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
    }

    // ===== ì˜¤ë”ë¶ ê¸°ëŠ¥ =====
    startOrderbookTracking() {
        this.generateOrderbookData();
        
        if (this.intervals.orderbook) return;
        
        this.intervals.orderbook = setInterval(() => {
            if (this.isTracking) {
                this.updateOrderbookData();
            }
        }, 1000);
    }

    generateOrderbookData() {
        const basePrice = 104000;
        this.orderbook.asks = [];
        this.orderbook.bids = [];

        for (let i = 0; i < 20; i++) {
            const price = basePrice + (i + 1) * 10;
            const quantity = Math.random() * 5 + 0.1;
            this.orderbook.asks.push({
                price: price,
                quantity: quantity,
                total: price * quantity
            });
        }

        for (let i = 0; i < 20; i++) {
            const price = basePrice - (i + 1) * 10;
            const quantity = Math.random() * 5 + 0.1;
            this.orderbook.bids.push({
                price: price,
                quantity: quantity,
                total: price * quantity
            });
        }

        this.updateOrderbookDisplay();
    }

    updateOrderbookData() {
        this.orderbook.asks.forEach(ask => {
            ask.quantity = Math.max(0.01, ask.quantity + (Math.random() - 0.5) * 0.5);
            ask.total = ask.price * ask.quantity;
        });

        this.orderbook.bids.forEach(bid => {
            bid.quantity = Math.max(0.01, bid.quantity + (Math.random() - 0.5) * 0.5);
            bid.total = bid.price * bid.quantity;
        });

        this.updateOrderbookDisplay();
    }

    updateOrderbookDisplay() {
        const asksContainer = document.getElementById('asks-list');
        const bidsContainer = document.getElementById('bids-list');
        
        if (asksContainer) {
            asksContainer.innerHTML = this.orderbook.asks.slice(0, 15).reverse().map(ask => `
                <div class="orderbook-item ask">
                    <span>$${ask.price.toFixed(2)}</span>
                    <span class="orderbook-quantity">${ask.quantity.toFixed(4)}</span>
                    <span class="orderbook-total">$${(ask.total / 1000).toFixed(1)}K</span>
                </div>
            `).join('');
        }

        if (bidsContainer) {
            bidsContainer.innerHTML = this.orderbook.bids.slice(0, 15).map(bid => `
                <div class="orderbook-item bid">
                    <span>$${bid.price.toFixed(2)}</span>
                    <span class="orderbook-quantity">${bid.quantity.toFixed(4)}</span>
                    <span class="orderbook-total">$${(bid.total / 1000).toFixed(1)}K</span>
                </div>
            `).join('');
        }

        const currentPrice = (this.orderbook.asks[0]?.price + this.orderbook.bids[0]?.price) / 2;
        const spread = this.orderbook.asks[0]?.price - this.orderbook.bids[0]?.price;

        document.getElementById('ob-current-price').textContent = '$' + currentPrice.toFixed(2);
        document.getElementById('spread').textContent = 'ìŠ¤í”„ë ˆë“œ: $' + spread.toFixed(2);
    }

    // ===== ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„° ìƒì„± =====
    generateSimulationData() {
        for (let i = 0; i < 10; i++) {
            if (Math.random() > 0.5) {
                const amount = Math.random() * 200 + 50;
                const tx = {
                    id: 'sim_btc_' + Date.now() + '_' + i,
                    hash: generateRandomHash(),
                    amount: amount,
                    type: 'bitcoin',
                    timestamp: Date.now() - Math.random() * 3600000,
                    fromAddress: generateRandomAddress(),
                    toAddress: generateRandomAddress(),
                    usdValue: amount * 104000
                };
                this.allTransactions.push(tx);
            } else {
                const amount = Math.random() * 3000 + 1000;
                const tx = {
                    id: 'sim_eth_' + Date.now() + '_' + i,
                    hash: '0x' + generateRandomHash(),
                    amount: amount,
                    type: 'ethereum',
                    timestamp: Date.now() - Math.random() * 3600000,
                    fromAddress: generateRandomAddress(),
                    toAddress: generateRandomAddress(),
                    usdValue: amount * 3400
                };
                this.allTransactions.push(tx);
            }
        }

        this.allTransactions.sort((a, b) => b.timestamp - a.timestamp);
    }

    startWhaleTracking() {
        console.log('ğŸ‹ Starting whale tracking...');
        
        if (this.whaleTracker) {
            console.log('ğŸ‹ Enhanced whale tracking (100k+) available');
            // WhaleTrackerëŠ” ìë™ìœ¼ë¡œ ì‹œì‘ë¨
        } else {
            console.log('ğŸ‹ Starting simulation whale tracking...');
            this.startWhaleSimulation();
        }
        
        // ê²Œì´ì§€ ì—…ë°ì´íŠ¸ ì‹œì‘
        this.startWhaleLSUpdate();
    }

    refreshWhaleData() {
        if (this.whaleTracker) {
            this.whaleTracker.refresh();
        } else {
            this.refreshData();
        }
    }

    startWhaleLSUpdate() {
        // ê¸°ì¡´ ê°„ê²©ì´ ìˆìœ¼ë©´ ì œê±°
        if (this.whaleLSInterval) {
            clearInterval(this.whaleLSInterval);
        }
        
        // ê²Œì´ì§€ ì—…ë°ì´íŠ¸ ì‹œì‘
        this.whaleLSInterval = setInterval(() => {
            if (this.isTracking) {
                this.updateWhaleLSRatio();
                console.log('ğŸ”„ Whale L/S ratio updated:', this.recentTrades?.length || 0, 'trades');
            }
        }, 1000); // 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
        
        // ì¦‰ì‹œ í•œ ë²ˆ ì—…ë°ì´íŠ¸
        this.updateWhaleLSRatio();
        console.log('âœ… Whale L/S gauge update started');
    }

    stopWhaleLSUpdate() {
        if (this.whaleLSInterval) {
            clearInterval(this.whaleLSInterval);
            this.whaleLSInterval = null;
        }
    }

    // ì™„ì „íˆ ìƒˆë¡œìš´ ì‹¤ì‹œê°„ ê³ ë˜ ê²Œì´ì§€ ì‹œìŠ¤í…œ - ì‹¤ì œ ê±°ë˜ ë°ì´í„° ê¸°ë°˜
    initializeWhaleGauge(retryCount = 0) {
        console.log('ğŸ¯ Initializing whale trade data based gauge system...');
        
        // ì»¨í…Œì´ë„ˆ ì¡´ì¬ í™•ì¸
        const tradeContainer = document.getElementById('whale-transactions');
        if (!tradeContainer) {
            if (retryCount < 5) {
                console.warn(`âŒ whale-transactions container not found, retrying in 1 second... (${retryCount + 1}/5)`);
                setTimeout(() => this.initializeWhaleGauge(retryCount + 1), 1000);
            } else {
                console.error('âŒ Failed to find whale-transactions container after 5 retries');
            }
            return;
        }
        
        // ì¦‰ì‹œ DOM ìš”ì†Œ í™•ì¸ ë° ì´ˆê¸°í™”
        this.initializeWhaleRatioDisplay();
        
        // ê²Œì´ì§€ ë°ì´í„° ì´ˆê¸°í™”
        this.whaleGaugeData = {
            longVolume: 0,
            shortVolume: 0,
            recentTrades: [],
            lastUpdate: Date.now(),
            isActive: true
        };
        
        // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì‹œì‘
        this.startRealTimeGaugeUpdates();
        
        // ì¦‰ì‹œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        this.runWhaleGaugeTest();
        
        console.log('âœ… Whale trade data based gauge system initialized');
    }
    
    initializeWhaleRatioDisplay() {
        console.log('ğŸ” Initializing whale ratio display elements...');
        
        // DOM ìš”ì†Œ í™•ì¸
        const whaleRatioDisplay = document.querySelector('.whale-ratio-display');
        const gaugeFillMini = document.getElementById('whale-ls-fill-mini');
        const ratioValueMini = document.getElementById('whale-ls-ratio-mini');
        const longPercentageMini = document.getElementById('long-percentage-mini');
        const shortPercentageMini = document.getElementById('short-percentage-mini');
        
        console.log('Elements found:', {
            whaleRatioDisplay: !!whaleRatioDisplay,
            gaugeFillMini: !!gaugeFillMini,
            ratioValueMini: !!ratioValueMini,
            longPercentageMini: !!longPercentageMini,
            shortPercentageMini: !!shortPercentageMini
        });
        
        if (!whaleRatioDisplay || !gaugeFillMini || !ratioValueMini) {
            console.error('âŒ Whale ratio display elements not found, retrying...');
            setTimeout(() => this.initializeWhaleRatioDisplay(), 500);
            return;
        }
        
        // ë¯¸ë‹ˆ ê²Œì´ì§€ ì´ˆê¸° ìƒíƒœ ì„¤ì •
        gaugeFillMini.style.width = '50%';
        gaugeFillMini.style.transition = 'width 0.3s ease';
        gaugeFillMini.style.background = 'linear-gradient(90deg, #ef4444 0%, #f59e0b 50%, #10b981 100%)';
        gaugeFillMini.style.visibility = 'visible';
        gaugeFillMini.style.opacity = '1';
        gaugeFillMini.style.display = 'block';
        gaugeFillMini.style.height = '100%';
        gaugeFillMini.style.borderRadius = '3px';
        gaugeFillMini.style.position = 'relative';
        
        ratioValueMini.textContent = '50.0%';
        ratioValueMini.style.color = '#ffffff';
        ratioValueMini.style.background = 'rgba(0, 0, 0, 0.3)';
        ratioValueMini.style.visibility = 'visible';
        ratioValueMini.style.opacity = '1';
        ratioValueMini.style.display = 'inline-block';
        ratioValueMini.style.fontWeight = '700';
        ratioValueMini.style.fontSize = '0.7rem';
        ratioValueMini.style.padding = '1px 4px';
        ratioValueMini.style.borderRadius = '8px';
        ratioValueMini.style.minWidth = '25px';
        ratioValueMini.style.textAlign = 'center';
        
        // ë¯¸ë‹ˆ í¼ì„¼í‹°ì§€ ì´ˆê¸° ìƒíƒœ ì„¤ì •
        if (longPercentageMini && shortPercentageMini) {
            longPercentageMini.textContent = '50.0%';
            shortPercentageMini.textContent = '50.0%';
        }
        
        console.log('âœ… Whale ratio display elements initialized');
    }
    
    // ì‹¤ì œ ê±°ë˜ ì»¨í…Œì´ë„ˆì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì™€ì„œ ê²Œì´ì§€ ê³„ì‚°
    calculateGaugeFromTradeContainer() {
        // whale-trades-containerì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        const tradeContainer = document.getElementById('whale-trades-container') || document.getElementById('whale-transactions');
        if (!tradeContainer) {
            console.error('âŒ Trade container not found');
            return;
        }
        
        // ê±°ë˜ ì•„ì´í…œë“¤ ìˆ˜ì§‘ (ìµœê·¼ 10ê°œ)
        const tradeItems = tradeContainer.querySelectorAll('.trade-item, .trade');
        if (tradeItems.length === 0) {
            console.log('No trades found, setting gauge to neutral');
            this.updateWhaleRatioDisplay(50, 0);
            return;
        }
        
        // ìµœê·¼ 10ê°œ ê±°ë˜ì˜ ë¡±/ìˆ ë¹„ìœ¨ ê³„ì‚°
        const recentTrades = Array.from(tradeItems).slice(0, 10);
        let buyCount = 0;
        let sellCount = 0;
        
        recentTrades.forEach(trade => {
            const sideElement = trade.querySelector('.trade-side');
            if (sideElement) {
                const isBuy = sideElement.textContent.includes('ë§¤ìˆ˜') || 
                             trade.classList.contains('buy') || 
                             trade.classList.contains('trade-buy');
                if (isBuy) {
                    buyCount++;
                } else {
                    sellCount++;
                }
            }
        });
        
        // ë¹„ìœ¨ ê³„ì‚° (ë§¤ìˆ˜ ë¹„ìœ¨)
        const totalTrades = buyCount + sellCount;
        const longRatio = totalTrades > 0 ? (buyCount / totalTrades) * 100 : 50;
        
        console.log(`ğŸ“Š Calculated from ${totalTrades} trades: ${longRatio.toFixed(1)}% (Buy: ${buyCount}, Sell: ${sellCount})`);
        
        // ê²Œì´ì§€ ì—…ë°ì´íŠ¸
        this.updateWhaleRatioDisplay(longRatio, totalTrades);
    }
    
    updateWhaleRatioDisplay(ratio, tradeCount) {
        const gaugeFillMini = document.getElementById('whale-ls-fill-mini');
        const gaugeNeedle = document.getElementById('whale-ls-needle');
        
        if (!gaugeFillMini || !gaugeNeedle) {
            console.warn('âŒ Gauge elements not found for update, skipping.');
            return;
        }
        
        try {
            // ê²Œì´ì§€ ì—…ë°ì´íŠ¸
            gaugeFillMini.style.width = `${ratio}%`;
            gaugeFillMini.style.transition = 'width 0.5s ease-out';
            
            // ë°”ëŠ˜ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            gaugeNeedle.style.left = `${ratio}%`;
            gaugeNeedle.style.transition = 'left 0.5s ease-out';
            
            console.log(`âœ… Whale ratio display updated: ${ratio.toFixed(1)}% (${tradeCount} trades)`);
            
        } catch (error) {
            console.error('âŒ Error updating whale ratio display:', error);
        }
    }
    
    startRealTimeGaugeUpdates() {
        // ê¸°ì¡´ ê°„ê²© ì •ë¦¬
        if (this.gaugeUpdateInterval) {
            clearInterval(this.gaugeUpdateInterval);
        }
        
        // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì‹œì‘ (1ì´ˆë§ˆë‹¤)
        this.gaugeUpdateInterval = setInterval(() => {
            this.updateGaugeFromRealData();
        }, 1000);
        
        console.log('ğŸ”„ Real-time gauge updates started');
    }
    
    updateGaugeFromRealData() {
        if (!this.whaleGaugeData || !this.whaleGaugeData.isActive) return;
        
        // ì»¨í…Œì´ë„ˆ ì¡´ì¬ í™•ì¸
        const tradeContainer = document.getElementById('whale-transactions');
        if (!tradeContainer) {
            console.warn('âŒ Trade container not found in updateGaugeFromRealData');
            return;
        }
        
        // ì‹¤ì œ ê±°ë˜ ì»¨í…Œì´ë„ˆì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì™€ì„œ ê³„ì‚°
        this.calculateGaugeFromTradeContainer();
    }
    
    updateGaugeDisplay(ratio, tradeCount) {
        // ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì‚¬ìš©
        this.updateWhaleRatioDisplay(ratio, tradeCount);
    }
    
    // ì‹¤ì œ ê±°ë˜ ë°ì´í„°ë¥¼ ê²Œì´ì§€ì— ì¶”ê°€
    addTradeToGauge(exchange, price, amount, side) {
        const tradeAmount = price * amount;
        
        // $100k ì´ìƒë§Œ ê²Œì´ì§€ì— ë°˜ì˜
        if (tradeAmount < 100000) return;
        
        if (!this.whaleGaugeData) {
            this.whaleGaugeData = {
                longVolume: 0,
                shortVolume: 0,
                recentTrades: [],
                lastUpdate: Date.now(),
                isActive: true
            };
        }
        
        // ê±°ë˜ ì¶”ê°€
        this.whaleGaugeData.recentTrades.push({
            timestamp: Date.now(),
            side: side,
            amount: tradeAmount,
            exchange: exchange,
            price: price,
            quantity: amount
        });
        
        console.log(`ğŸ’° Added to gauge: ${exchange} ${side} $${(tradeAmount/1000000).toFixed(2)}M`);
        
        // ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        this.updateGaugeFromRealData();
    }
    
    // ê²Œì´ì§€ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ (ë””ë²„ê¹…ìš©)
    testGaugeWithRealData() {
        console.log('ğŸ§ª Testing gauge with simulated real data...');
        
        // í…ŒìŠ¤íŠ¸ ê±°ë˜ë“¤ ì¶”ê°€
        const testTrades = [
            { exchange: 'BINANCE', price: 100000, amount: 15, side: 'BUY' },
            { exchange: 'BYBIT', price: 100000, amount: 12, side: 'BUY' },
            { exchange: 'OKX', price: 100000, amount: 8, side: 'SELL' },
            { exchange: 'BITGET', price: 100000, amount: 20, side: 'BUY' },
            { exchange: 'MEXC', price: 100000, amount: 10, side: 'SELL' }
        ];
        
        testTrades.forEach(trade => {
            this.addTradeToGauge(trade.exchange, trade.price, trade.amount, trade.side);
        });
        
        console.log('âœ… Test data added to gauge');
    }

    runWhaleGaugeTest() {
        console.log('ğŸ§ª Running whale gauge test...');
        
        // 2ì´ˆ í›„ ì²« ë²ˆì§¸ í…ŒìŠ¤íŠ¸
        setTimeout(() => {
            this.updateWhaleRatioDisplay(75, 5);
            console.log('âœ… Test 1: 75% (Long bias)');
        }, 2000);
        
        // 5ì´ˆ í›„ ë‘ ë²ˆì§¸ í…ŒìŠ¤íŠ¸
        setTimeout(() => {
            this.updateWhaleRatioDisplay(25, 8);
            console.log('âœ… Test 2: 25% (Short bias)');
        }, 5000);
        
        // 8ì´ˆ í›„ ì¤‘ë¦½ìœ¼ë¡œ ë³µê·€
        setTimeout(() => {
            this.updateWhaleRatioDisplay(50, 0);
            console.log('âœ… Test 3: 50% (Neutral)');
        }, 8000);
    }

    // ë ˆì´ì•„ì›ƒ ê´€ë¦¬ ê¸°ëŠ¥
    initializeLayoutManager() {
        this.layoutMode = false;
        const grid = document.getElementById('dashboard-grid');
        const cards = document.querySelectorAll('.dashboard-card');
        
        cards.forEach(card => {
            card.addEventListener('mousedown', (e) => this.handleMouseDown(e, card));
            
            // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ì¶”ê°€
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            card.appendChild(resizeHandle);
            
            resizeHandle.addEventListener('mousedown', (e) => this.handleResizeStart(e, card));
        });
    }

    toggleLayoutEditMode() {
        this.layoutMode = !this.layoutMode;
        const grid = document.getElementById('dashboard-grid');
        const cards = document.querySelectorAll('.dashboard-card');
        
        if (this.layoutMode) {
            grid.classList.add('layout-edit-mode');
            cards.forEach(card => {
                card.setAttribute('draggable', 'true');
                card.classList.add('editable');
            });
            document.getElementById('layout-reset').style.display = 'inline-flex';
            document.getElementById('layout-save').style.display = 'inline-flex';
            document.getElementById('layout-toggle').classList.add('active');
        } else {
            grid.classList.remove('layout-edit-mode');
            cards.forEach(card => {
                card.setAttribute('draggable', 'false');
                card.classList.remove('editable');
            });
            document.getElementById('layout-reset').style.display = 'none';
            document.getElementById('layout-save').style.display = 'none';
            document.getElementById('layout-toggle').classList.remove('active');
        }
    }

    handleMouseDown(e, card) {
        if (!this.layoutMode) return;
        
        const startX = e.clientX;
        const startY = e.clientY;
        const startLeft = card.offsetLeft;
        const startTop = card.offsetTop;
        
        card.classList.add('dragging');
        
        const handleMouseMove = (e) => {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            
            card.style.transform = `translate(${dx}px, ${dy}px)`;
        };
        
        const handleMouseUp = () => {
            card.classList.remove('dragging');
            card.style.transform = '';
            
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
            this.updateCardPosition(card);
        };
        
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    }

    updateCardPosition(card) {
        const grid = document.getElementById('dashboard-grid');
        const rect = grid.getBoundingClientRect();
        const cards = Array.from(document.querySelectorAll('.dashboard-card'));
        const index = cards.indexOf(card);
        
        // ìƒˆ ìœ„ì¹˜ ê³„ì‚°
        const cardRect = card.getBoundingClientRect();
        const centerX = cardRect.left + cardRect.width / 2;
        const centerY = cardRect.top + cardRect.height / 2;
        
        // ê°€ì¥ ê°€ê¹Œìš´ ì¹´ë“œ ì°¾ê¸°
        let closestCard = null;
        let minDistance = Infinity;
        
        cards.forEach((otherCard, otherIndex) => {
            if (otherCard === card) return;
            
            const otherRect = otherCard.getBoundingClientRect();
            const otherCenterX = otherRect.left + otherRect.width / 2;
            const otherCenterY = otherRect.top + otherRect.height / 2;
            
            const distance = Math.sqrt(
                Math.pow(centerX - otherCenterX, 2) + 
                Math.pow(centerY - otherCenterY, 2)
            );
            
            if (distance < minDistance) {
                minDistance = distance;
                closestCard = otherCard;
            }
        });
        
        if (closestCard) {
            const closestIndex = cards.indexOf(closestCard);
            if (closestIndex > index) {
                closestCard.parentNode.insertBefore(card, closestCard.nextSibling);
            } else {
                closestCard.parentNode.insertBefore(card, closestCard);
            }
        }
    }
    
    handleResizeStart(e, card) {
        if (!this.layoutMode) return;
        e.preventDefault();
        
        const startWidth = card.offsetWidth;
        const startHeight = card.offsetHeight;
        const startX = e.clientX;
        const startY = e.clientY;
        
        const handleMouseMove = (e) => {
            const width = startWidth + (e.clientX - startX);
            const height = startHeight + (e.clientY - startY);
            
            // ê·¸ë¦¬ë“œ ë‚´ì—ì„œë§Œ í¬ê¸° ì¡°ì ˆë˜ë„ë¡ ì œí•œ
            const grid = document.getElementById('dashboard-grid');
            const gridRect = grid.getBoundingClientRect();
            const cardLeft = parseInt(card.style.left || 0);
            const maxWidth = gridRect.width - cardLeft;
            
            card.style.width = `${Math.max(280, Math.min(maxWidth, width))}px`;
            card.style.height = `${Math.max(200, height)}px`;
            
            // ê·¸ë¦¬ë“œ ë†’ì´ ìë™ ì¡°ì •
            const bottomY = parseInt(card.style.top || 0) + height + 100;
            if (bottomY > grid.offsetHeight) {
                grid.style.minHeight = `${bottomY}px`;
            }
        };
        
        const handleMouseUp = () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            this.saveLayout();
        };
        
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    }
    
    saveLayout() {
        const grid = document.getElementById('dashboard-grid');
        const cards = grid.querySelectorAll('.dashboard-card');
        
        const layout = Array.from(cards).map(card => ({
            id: card.dataset.cardId,
            width: card.style.width,
            height: card.style.height,
            top: card.style.top,
            left: card.style.left
        }));
        
        localStorage.setItem('dashboardLayout', JSON.stringify(layout));
    }
    
    loadLayout() {
        const savedLayout = localStorage.getItem('dashboardLayout');
        if (!savedLayout) return;
        
        try {
            const layout = JSON.parse(savedLayout);
            const grid = document.getElementById('dashboard-grid');
            
            layout.forEach(item => {
                const card = grid.querySelector(`[data-card-id="${item.id}"]`);
                if (card) {
                    if (item.width) card.style.width = item.width;
                    if (item.height) card.style.height = item.height;
                    if (item.top) card.style.top = item.top;
                    if (item.left) card.style.left = item.left;
                }
            });
        } catch (error) {
            console.error('ë ˆì´ì•„ì›ƒ ë¡œë“œ ì¤‘ ì˜¤ë¥˜:', error);
        }
    }

    /**
     * @deprecated The whale gauge feature is no longer in use. This function is kept to prevent errors from old calls.
     */
    initializeWhaleGauge() {
        // This function is deprecated and intentionally left empty.
        console.warn("initializeWhaleGauge is deprecated and no longer used.");
    }

    /**
     * @deprecated The whale display feature is no longer in use. This function is kept to prevent errors from old calls.
     */
    updateWhaleDisplay() {
        // This function is deprecated and intentionally left empty.
    }

    /**
     * @deprecated The whale ratio display feature is no longer in use. This function is kept to prevent errors from old calls.
     */
    updateWhaleRatioDisplay() {
        // This function is deprecated and intentionally left empty.
    }
}

// ë°ëª¨ ë°ì´í„° ìƒì„± í•¨ìˆ˜ (í…ŒìŠ¤íŠ¸ìš©)
function generateDemoData() {
    const tracker = window.tradingPlatform;
    if (!tracker) {
        console.error('Trading Platform not initialized');
        return;
    }
    
    const now = Date.now();
    const randomBtcAmount = Math.random() * 100 + 50;
    const randomEthAmount = Math.random() * 2000 + 1000;
    
    const demoBtcTx = {
        id: 'demo_btc_' + now + '_' + Math.random().toString(36).substr(2, 9),
        hash: generateRandomHash(),
        amount: randomBtcAmount,
        type: 'bitcoin',
        timestamp: now,
        fromAddress: generateRandomAddress(),
        toAddress: generateRandomAddress(),
        usdValue: randomBtcAmount * 104000
    };
    
    const demoEthTx = {
        id: 'demo_eth_' + now + '_' + Math.random().toString(36).substr(2, 9),
        hash: '0x' + generateRandomHash(),
        amount: randomEthAmount,
        type: 'ethereum',
        timestamp: now,
        fromAddress: generateRandomAddress(),
        toAddress: generateRandomAddress(),
        usdValue: randomEthAmount * 3400
    };
    
    tracker.allTransactions.unshift(demoBtcTx);
    tracker.allTransactions.unshift(demoEthTx);
    
    tracker.updateWhaleDisplay();
    tracker.updateStats();
    tracker.showNotification(`ë°ëª¨ ë°ì´í„° ì¶”ê°€: ${randomBtcAmount.toFixed(2)} BTC, ${randomEthAmount.toFixed(2)} ETH`, 'success');
}

// ëœë¤ í•´ì‹œ ìƒì„±
function generateRandomHash() {
    return Array.from({length: 64}, () => Math.floor(Math.random() * 16).toString(16)).join('');
}

// ëœë¤ ì´ë”ë¦¬ì›€ ì£¼ì†Œ ìƒì„±
function generateRandomAddress() {
    const hash = generateRandomHash();
    return '0x' + hash.substring(0, 40);
}

// í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
document.addEventListener('DOMContentLoaded', () => {
    // ê¸€ë¡œë²Œ í•¨ìˆ˜ë“¤ ì¦‰ì‹œ ë“±ë¡
    window.testGaugeManual = function(ratio) {
        console.log(`ğŸ¯ Manual gauge test with ratio: ${ratio}%`);
        if (window.tradingPlatform) {
            window.tradingPlatform.updateWhaleRatioDisplay(ratio, 0);
        } else {
            console.error('TradingPlatform not found!');
        }
    };

    window.calculateFromContainer = function() {
        console.log('ğŸ“Š Calculating gauge from trade container...');
        if (window.tradingPlatform) {
            window.tradingPlatform.calculateGaugeFromTradeContainer();
        } else {
            console.error('TradingPlatform not found!');
        }
    };

    window.testGaugeWithRealData = function() {
        console.log('ğŸ§ª Testing gauge with real data simulation...');
        if (window.tradingPlatform) {
            window.tradingPlatform.testGaugeWithRealData();
        } else {
            console.error('TradingPlatform not found!');
        }
    };

    window.addTestTrade = function(exchange = 'BINANCE', side = 'BUY', amount = 20) {
        console.log(`ğŸ’° Adding test trade: ${exchange} ${side} ${amount} BTC`);
        if (window.tradingPlatform) {
            window.tradingPlatform.addSimulatedTrade(exchange, 100000, amount, side);
        } else {
            console.error('TradingPlatform not found!');
        }
    };

    window.clearGaugeData = function() {
        console.log('ğŸ—‘ï¸ ê²Œì´ì§€ ë°ì´í„° ì´ˆê¸°í™” ì¤‘...');
        if (window.tradingPlatform) {
            window.tradingPlatform.recentTrades = [];
            window.tradingPlatform.updateWhaleRatioDisplay(50, 0);
            console.log('âœ… ê²Œì´ì§€ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else {
            console.error('âŒ TradingPlatformì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤! í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
        }
    };

    window.addMultipleTestTrades = function() {
        console.log('ğŸ’° í…ŒìŠ¤íŠ¸ ê±°ë˜ë“¤ì„ ì¶”ê°€í•˜ëŠ” ì¤‘...');
        if (window.tradingPlatform) {
            const trades = [
                { exchange: 'BINANCE', side: 'BUY', amount: 25 },
                { exchange: 'BYBIT', side: 'SELL', amount: 15 },
                { exchange: 'OKX', side: 'BUY', amount: 30 },
                { exchange: 'BITGET', side: 'BUY', amount: 20 },
                { exchange: 'MEXC', side: 'SELL', amount: 10 }
            ];

            trades.forEach((trade, index) => {
                setTimeout(() => {
                    const price = 100000 + (Math.random() - 0.5) * 10000;
                    const quantity = trade.amount;
                    window.tradingPlatform.addSimulatedTrade(trade.exchange, price, quantity, trade.side);
                }, index * 500);
            });
            console.log('âœ… í…ŒìŠ¤íŠ¸ ê±°ë˜ë“¤ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else {
            console.error('âŒ TradingPlatformì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤! í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
        }
    };

    window.addSingleTestTrade = function(side = 'BUY') {
        console.log(`ğŸ’° ë‹¨ì¼ í…ŒìŠ¤íŠ¸ ê±°ë˜ ì¶”ê°€: ${side}`);
        if (window.tradingPlatform) {
            const exchanges = ['BINANCE', 'BYBIT', 'OKX', 'BITGET', 'MEXC'];
            const exchange = exchanges[Math.floor(Math.random() * exchanges.length)];
            const price = 100000 + (Math.random() - 0.5) * 10000;
            const amount = Math.random() * 50 + 10;
            window.tradingPlatform.addSimulatedTrade(exchange, price, amount, side);
        } else {
            console.error('âŒ TradingPlatformì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤! í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
        }
    };

    window.showTradeStats = function() {
        if (window.tradingPlatform) {
            console.log('ğŸ“Š ê±°ë˜ í†µê³„:');
            console.log('ìµœê·¼ ê±°ë˜ ìˆ˜:', window.tradingPlatform.recentTrades.length);
            console.log('ìµœê·¼ ê±°ë˜ë“¤:', window.tradingPlatform.recentTrades);
            
            const longTrades = window.tradingPlatform.recentTrades.filter(t => t.side === 'BUY');
            const shortTrades = window.tradingPlatform.recentTrades.filter(t => t.side === 'SELL');
            
            console.log('ë¡± ê±°ë˜ ìˆ˜:', longTrades.length);
            console.log('ìˆ ê±°ë˜ ìˆ˜:', shortTrades.length);
            
            const longVolume = longTrades.reduce((sum, t) => sum + t.amount, 0);
            const shortVolume = shortTrades.reduce((sum, t) => sum + t.amount, 0);
            
            console.log('ë¡± ë³¼ë¥¨:', longVolume);
            console.log('ìˆ ë³¼ë¥¨:', shortVolume);
            
            const totalVolume = longVolume + shortVolume;
            const ratio = totalVolume > 0 ? (longVolume / totalVolume) * 100 : 50;
            console.log('ë¡± ë¹„ìœ¨:', ratio.toFixed(1) + '%');
        } else {
            console.error('âŒ TradingPlatformì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤! í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
        }
    };

    window.startWhaleSimulation = function() {
        console.log('ğŸ‹ ê³ ë˜ ê±°ë˜ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘...');
        if (window.tradingPlatform) {
            window.tradingPlatform.startWhaleSimulation();
            console.log('âœ… ê³ ë˜ ê±°ë˜ ì‹œë®¬ë ˆì´ì…˜ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else {
            console.error('âŒ TradingPlatformì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤! í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
        }
    };

    window.stopWhaleSimulation = function() {
        console.log('â¹ï¸ ê³ ë˜ ê±°ë˜ ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì§€...');
        if (window.tradingPlatform && window.tradingPlatform.whaleSimulationInterval) {
            clearInterval(window.tradingPlatform.whaleSimulationInterval);
            window.tradingPlatform.whaleSimulationInterval = null;
            console.log('âœ… ê³ ë˜ ê±°ë˜ ì‹œë®¬ë ˆì´ì…˜ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else {
            console.error('âŒ TradingPlatformì„ ì°¾ì„ ìˆ˜ ì—†ê±°ë‚˜ ì‹œë®¬ë ˆì´ì…˜ì´ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹™ë‹ˆë‹¤.');
        }
    };

    // ì¶”ê°€ ë””ë²„ê¹… í•¨ìˆ˜
    window.checkGaugeElements = function() {
        const gaugeFillMini = document.getElementById('whale-ls-fill-mini');
        const ratioValueMini = document.getElementById('whale-ls-ratio-mini');
        const longPercentageMini = document.getElementById('long-percentage-mini');
        const shortPercentageMini = document.getElementById('short-percentage-mini');
        const tradeContainer = document.getElementById('whale-transactions');
        
        console.log('ğŸ” Gauge elements check:');
        console.log('  - whale-ls-fill-mini:', gaugeFillMini);
        console.log('  - whale-ls-ratio-mini:', ratioValueMini);
        console.log('  - long-percentage-mini:', longPercentageMini);
        console.log('  - short-percentage-mini:', shortPercentageMini);
        console.log('  - whale-transactions:', tradeContainer);
        
        if (tradeContainer) {
            const tradeItems = tradeContainer.querySelectorAll('.trade-item');
            console.log('  - Trade items count:', tradeItems.length);
        }
        
        if (gaugeFillMini) {
            console.log('  - Current width:', gaugeFillMini.style.width);
            console.log('  - Current background:', gaugeFillMini.style.background);
        }
        
        if (ratioValueMini) {
            console.log('  - Current text:', ratioValueMini.textContent);
            console.log('  - Current color:', ratioValueMini.style.color);
        }
        
        if (window.tradingPlatform && window.tradingPlatform.whaleGaugeData) {
            console.log('  - Recent trades:', window.tradingPlatform.whaleGaugeData.recentTrades.length);
            console.log('  - Gauge data:', window.tradingPlatform.whaleGaugeData);
        }
        
        return { gaugeFillMini, ratioValueMini, longPercentageMini, shortPercentageMini, tradeContainer };
    };

    // ê¸€ë¡œë²Œ í•¨ìˆ˜ë“¤ ë“±ë¡
    window.generateDemoData = generateDemoData;
    
    setTimeout(() => {
        try {
            console.log('ğŸš€ Starting Trading Analytics Platform initialization...');
            window.tradingPlatform = new TradingAnalyticsPlatform();
            
            console.log('âœ… Trading Analytics Platform ready!');
            
        } catch (error) {
            console.error('Error initializing Trading Platform:', error);
            
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #f44336;
                color: white;
                padding: 1rem;
                border-radius: 8px;
                z-index: 1000;
                max-width: 300px;
            `;
            errorDiv.innerHTML = `
                <strong>ì´ˆê¸°í™” ì˜¤ë¥˜</strong><br>
                í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ ì£¼ì„¸ìš”.
            `;
            document.body.appendChild(errorDiv);
            
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 5000);
        }
    }, 100);

    // ëŒ€ì‹œë³´ë“œ ë¡œë”© ì™„ë£Œ ì²˜ë¦¬
    setTimeout(() => {
        const grid = document.getElementById('dashboard-grid');
        if (grid) {
            grid.classList.add('loaded');
            console.log('âœ… Dashboard layout faded in.');
        }
    }, 300); // ëª¨ë“  ì»´í¬ë„ŒíŠ¸ ë Œë”ë§ í›„ fade-in
});