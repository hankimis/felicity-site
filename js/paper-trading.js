// üî• Paper Trading Engine for Community Page
// - USDT ÏÑ†Î¨º Î™®Ïùò Ìà¨Ïûê
// - ÏãúÏû•Í∞Ä/ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏, Î°±/Ïàè, Î†àÎ≤ÑÎ¶¨ÏßÄ, ÍµêÏ∞®/Í≤©Î¶¨ Î™®Îìú(Í∞ÑÏÜåÌôî)
// - Ïò§ÎçîÎ∂Å/Ï≤¥Í≤∞ Î¶¨Ïä§Ìä∏Îäî Í∞ÄÍ≤©ÏùÑ Ï§ëÏã¨ÏúºÎ°ú ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏÉùÏÑ±
// - ÏûîÍ≥†/Ìè¨ÏßÄÏÖòÏùÄ localStorageÏóê Ï†ÄÏû•

(function () {
  const STORAGE_KEY = 'paperTradingState_v1';

  // =============================
  // CONFIG
  // =============================
  const CONFIG = {
    binanceWsBase: 'wss://fstream.binance.com/ws',
    binanceApiBase: 'https://fapi.binance.com',
    orderbookDepthStream: (sym) => `${CONFIG.binanceWsBase}/${sym}@depth20`,
    bookTickerStream: (sym) => `${CONFIG.binanceWsBase}/${sym}@bookTicker`,
    depthRest: (sym, limit=25) => `${CONFIG.binanceApiBase}/fapi/v1/depth?symbol=${sym}&limit=${limit}`,
    tickerRest: (sym) => `${CONFIG.binanceApiBase}/fapi/v1/ticker/bookTicker?symbol=${sym}`,
    leverageBracketRest: (sym) => `${CONFIG.binanceApiBase}/fapi/v1/leverageBracket?symbol=${sym}`,
    ui: {
      minOrderbookRows: 9,
      rowHeight: 24,
      ladderTick: 0.1,
    },
    fees: { taker: 0.0006, maker: 0.0002 },
    fundingIntervalMs: 60*60*1000,
  };

  const defaultState = {
    symbol: 'BTCUSDT',
    balanceUSDT: 10000, // ÏãúÏûë ÏûêÎ≥∏
    equityUSDT: 10000,
    leverage: 15,
    marginMode: 'cross', // cross | isolated
    positions: [], // { id, symbol, side, entry, amount, leverage, margin, mode }
    openOrders: [], // { id, symbol, side, price, amount, leverage, mode, status }
    lastPrice: 0,
    history: [],
    fundingRate: 0.0001,
    lastFundingTs: 0,
  };
  const FEE_TAKER = CONFIG.fees.taker; // 6 bps
  const FEE_MAKER = CONFIG.fees.maker; // 2 bps
  const FUNDING_INTERVAL_MS = CONFIG.fundingIntervalMs; // ÌÖåÏä§Ìä∏: 1ÏãúÍ∞Ñ
  const PRICE_TICK = (CONFIG.ticks && CONFIG.ticks.price) || 0.1;
  const AMOUNT_TICK = (CONFIG.ticks && CONFIG.ticks.amount) || 0.0001;
  const MMR_TTL = (CONFIG.cache && CONFIG.cache.mmrTtlMs) || (10*60*1000);

  const dlog = (...args) => { if (CONFIG.debug) { try { console.log('[PT]', ...args); } catch(_) {} } };

  class PaperTradingEngine {
    constructor() {
      this.state = this.loadState();
      // ÏÉà MarketSocketsÎ°ú ÎåÄÏ≤¥ (Í∏∞Ï°¥ MarketDataManager Ìè¥Î∞± Ïú†ÏßÄ)
      if (window.MarketSockets) {
        this.market = new window.MarketSockets(this.state.symbol, {
          onPrice: (mid) => { this.state.lastPrice = Number(mid); this.renderPrices(); this.updatePnL(); },
          onDepth: (m) => {
            try {
              this.orderbookState = {
                bids: (m.b || []).map(([p,q]) => ({ price: Number(p), size: Number(q) })),
                asks: (m.a || []).map(([p,q]) => ({ price: Number(p), size: Number(q) })),
              };
              this.renderDepth();
            } catch(_) {}
          }
        });
        this.market.startPrice();
        this.market.startOrderbook();
      } else {
        this.market = new (window.MarketDataManager || function(){})();
      }
      this.priceTimer = null;
      this.orderbookState = { asks: [], bids: [] };
      this.orderbookLevels = 16;
      this.ladderTick = CONFIG.ui.ladderTick; // Í∞ÄÍ≤© Í≥†Ï†ï Í∞ÑÍ≤© 0.1
      // Î†åÎçî Ïä§Î°úÌãÄÎü¨
      this._rafQueued = false;
      this.ladderLevels = 15; // Í∞Å ÏÇ¨Ïù¥Îìú Í≥†Ï†ï Ìñâ Ïàò
      this.ladderCenter = null; // Í≥†Ï†ï Í∏∞Ï§ÄÍ∞Ä
      this.pricePrecision = 1; // Í∞ÑÏÜåÌôîÎêú Í∞ÄÍ≤© ÏûêÎ¶¨Ïàò
      this.amountPrecision = 4;
      this.priceTouched = false;
      this.prev = { lastPrice: null, uPnL: null, marginBalance: null };
      this.prevPnlByPos = new Map();
      this.firstPriceReceived = false;
      this.user = null;
      this.guestLocked = false;
      this._syncTimer = null;
      this._obDebounce = null; // orderbook UI ÎîîÎ∞îÏö¥Ïä§ ÌÉÄÏù¥Î®∏
      this._lastPnlRender = 0; // PnL/Í∞ÄÍ≤© Î†åÎçî Ïä§Î°úÌãÄ
      this._obRowCache = new Map(); // Í∞ÄÍ≤©ÌÇ§->Ìñâ ÏóòÎ¶¨Î®ºÌä∏ Ï∫êÏãú
      this._obMounted = false;
      this._mmrBrackets = null; // Ïú†ÏßÄÏ¶ùÍ±∞Í∏à Î∏åÎûòÌÇ∑ (REST Î°úÎìú)
      this._obWorker = null; // Ïò§ÎçîÎ∂Å Í≥ÑÏÇ∞Ïö© Web Worker
      this._obLastPriceArrays = null; // worker Í≤∞Í≥º Îß§ÌïëÏö©
      this._obLastMsgHash = '';
      this._obBucketSig = '';
      this._hidden = document.hidden; // Í∞ÄÏãúÏÑ± ÏÉÅÌÉú
      this._online = navigator.onLine !== false; // Ïò®ÎùºÏù∏ ÏÉÅÌÉú
      this._priceAbort = null; // REST Í∞ÄÍ≤© AbortController
      this._depthAbort = null; // REST ÍπäÏù¥ AbortController
      this._fmtMax = (CONFIG.cache && CONFIG.cache.formatLruSize) || 64;

      this.cacheElements();
      this.bindEvents();
      this.initAuthIntegration();
      this.start();
      this.render();
      this.renderPositionsSkeleton();
      // Ï†ÄÏû•/ÎèôÍ∏∞Ìôî ÎîîÎ∞îÏö¥Ïä§ ÎûòÌçº
      this._saveTimer = null;
      this._lastSavedJson = '';
      this.initOrderbookWorker();
      this.initVisibilityAndOnlineHandlers();

      // ONBIT Miner UI Íµ¨ÎèÖ (balance-grid Ï§ëÏïô)
      try {
        if (window.onbitMiner) {
          window.onbitMiner.subscribeUI(document.getElementById('acc-onbit'));
          window.onbitMiner.setExternalControlled(true); // Ìï©ÏÇ∞ ÌëúÍ∏∞Îäî Ïó¨Í∏∞ÏÑúÎßå Ï†úÏñ¥
          window.addEventListener('onbit:balance', (e) => {
            const el = document.getElementById('acc-onbit');
            if (el && e && e.detail && typeof e.detail.balance === 'number') {
              // ÏµúÏã† ÌîÑÎ¶¨Î∑∞ÏôÄ Ìï©ÏÇ∞ ÌëúÏãú
              const base = Number(e.detail.balance || 0);
              this._onbitBase = base;
              const total = base + Number(this._onbitPreview || 0);
              this.updateOnbitDisplay(total);
            }
          });
        }
      } catch(_) {}

      // Ï±ÑÍµ¥ ÎØ∏Î¶¨Î≥¥Í∏∞Îäî Ìè¨ÏßÄÏÖò PnLÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Í≥†Ï†ï Î≥¥ÏÉÅ(ÏàòÏùµ 1, ÏÜêÏã§ 0.1) Ìï©ÏÇ∞
      this._miningPosAccUSDT = 0; // ÏÇ¨Ïö© ÏïàÌï®
      this._miningNegAccUSDT = 0; // ÏÇ¨Ïö© ÏïàÌï®
      this._lastMiningAwardTs = 0;
      this._onbitPreview = 0; // ÌòÑÏû¨ Ìè¨ÏßÄÏÖò Í∏∞Ï§Ä ÏòàÏÉÅ Ï±ÑÍµ¥Îüâ(Ìï©Í≥Ñ)
    }

    initOrderbookWorker() {
      try {
        const url = '../js/orderbook-worker.js';
        const w = new Worker(url);
        w.onmessage = (e) => {
          const d = e.data || {};
          if (!this._obLastPriceArrays) return;
          const { asksPrices, bidsPrices } = this._obLastPriceArrays;
          const { askSizes, bidSizes, askCumMax, bidCumMax } = d;
          if (!Array.isArray(askSizes) || !Array.isArray(bidSizes)) return;
          this.drawOrderbook(asksPrices, bidsPrices, askSizes, bidSizes, askCumMax, bidCumMax);
        };
        w.onerror = () => { try { w.terminate(); } catch(_) {}; this._obWorker = null; setTimeout(()=>this.initOrderbookWorker(), 300); };
        w.onmessageerror = () => { try { w.terminate(); } catch(_) {}; this._obWorker = null; setTimeout(()=>this.initOrderbookWorker(), 300); };
        this._obWorker = w;
      } catch (_) {
        this._obWorker = null;
      }
    }

    initVisibilityAndOnlineHandlers() {
      const onVis = () => {
        const hidden = !!document.hidden;
        this._hidden = hidden;
        // Ïà®Í≤®ÏßÄÎ©¥ ÏÜåÏºìÎßå Ïú†ÏßÄ, Î†åÎçî ÏùºÏãú Ï§ëÏßÄ. Îã§Ïãú Î≥¥Ïù¥Î©¥ Ï¶âÏãú Ìïú Î≤à Î†åÎçî/Í∞ÄÍ≤© fetch
        if (!hidden) {
          this.renderDepth();
          this.fetchInitialPrice();
          // hidden Ïú†ÏßÄ ÏãúÍ∞Ñ Î¶¨ÏÖã
          this._hiddenSince = 0;
        }
      };
      const onOnline = () => {
        this._online = true;
        // Ï¶âÏãú Ïû¨Ïó∞Í≤∞ Ìä∏Î¶¨Í±∞
        const jitter = Math.floor(Math.random()*200)+50; // 50~250ms ÏßÄÌÑ∞
        setTimeout(() => {
          try { this.market && this.market.startPrice && this.market.startPrice(); } catch(_) {}
          try { this.market && this.market.startOrderbook && this.market.startOrderbook(); } catch(_) {}
        }, jitter);
      };
      const onOffline = () => { this._online = false; };
      document.addEventListener('visibilitychange', onVis);
      window.addEventListener('online', onOnline);
      window.addEventListener('offline', onOffline);
      // beforeunload flush
      window.addEventListener('beforeunload', () => {
        try {
          const json = JSON.stringify(this.state);
          localStorage.setItem(STORAGE_KEY, json);
        } catch (_) {}
      });
      // hidden 30s Ïù¥ÏÉÅÏù¥Î©¥ worker Ï¢ÖÎ£å, Îã§Ïãú Î≥¥Ïù¥Î©¥ Ïû¨ÏÉùÏÑ±
      setInterval(() => {
        if (this._hidden) {
          this._hiddenSince = (this._hiddenSince||0) + 1000;
          if (this._hiddenSince > 30000 && this._obWorker) {
            try { this._obWorker.terminate(); } catch(_) {}
            this._obWorker = null;
          }
        }
      }, 1000);
    }

    cacheElements() {
      this.el = {
        symbol: document.getElementById('pt-symbol'),
        lastPrice: document.getElementById('pt-last-price'),
        mid: document.getElementById('orderbook-mid-price'),
        asks: document.getElementById('orderbook-asks'),
        bids: document.getElementById('orderbook-bids'),
        price: document.getElementById('pt-price'),
        amount: document.getElementById('pt-amount'),
        amountPercent: document.getElementById('pt-amount-percent'),
        percent: document.getElementById('pt-percent'),
        balance: document.getElementById('pt-balance'),
        cost: document.getElementById('pt-cost'),
        feeBasis: document.getElementById('pt-fee-basis'),
        feeEstimate: document.getElementById('pt-fee-estimate'),
        btnLong: document.getElementById('pt-open-long'),
        btnShort: document.getElementById('pt-open-short'),
        positionsUnder: document.getElementById('positions-under-chart'),
        positionsTableBody: document.getElementById('positions-table-body'),
        btnCloseAll: document.getElementById('pt-close-all'),
        ordersTableBody: document.getElementById('orders-table-body'),
      };
      // Îã®Ïùº Î™®Îìú (Open Ï†ÑÏö©)
    }

    bindEvents() {
      const sidebar = document.getElementById('paper-trading-sidebar');
      if (!sidebar) {
        console.warn('paper-trading: sidebar not found, proceeding to bind global handlers');
      }

      if (sidebar) sidebar.addEventListener('click', (e) => {
        const tab = e.target.closest('.tab');
        if (tab) {
          sidebar.querySelectorAll('.tab').forEach((b) => b.classList.remove('active'));
          tab.classList.add('active');
          // Ïò§ÎçîÎ∂Å/Í≥†ÎûòÌÉêÏßÄ ÌÉ≠ Ï†ÑÌôò
          const key = tab.getAttribute('data-tab');
          const obBody = document.getElementById('orderbook-body');
          const whaleBody = document.getElementById('whale-tab-body');
          if (key === 'whale') {
            // Ìå®ÎÑê ÎÜíÏù¥/Î†àÏù¥ÏïÑÏõÉÏùÄ Í≥†Ï†ï, ÏΩòÌÖêÏ∏†Îßå Ï†ÑÌôò
            if (obBody) obBody.style.display = 'none';
            if (whaleBody) whaleBody.style.display = '';
          } else {
            if (obBody) obBody.style.display = '';
            if (whaleBody) whaleBody.style.display = 'none';
          }
        }

        // trade-tab Ï†úÍ±∞Îê®

        const orderType = e.target.closest('.order-type');
        if (orderType) {
          sidebar.querySelectorAll('.order-type').forEach((b) => b.classList.remove('active'));
          orderType.classList.add('active');
          // a11y
          sidebar.querySelectorAll('.order-type').forEach((b)=>b.setAttribute('aria-selected', b.classList.contains('active')?'true':'false'));
          const type = orderType.getAttribute('data-type');
          const isMkt = type === 'market';
          this.el.price.disabled = isMkt;
          const form = document.getElementById('order-form');
          if (form) form.classList.toggle('is-market', isMkt);
          this.el.price.placeholder = isMkt ? 'Fill at market price' : '';
          if (!isMkt && !this.priceTouched && !this.el.price.value) this.el.price.value = (this.state.lastPrice || 0).toFixed(1);
        }

        const modeBtn = e.target.closest('.mode');
        if (modeBtn) {
          sidebar.querySelectorAll('.mode').forEach((b) => b.classList.remove('active'));
          modeBtn.classList.add('active');
          this.state.marginMode = modeBtn.getAttribute('data-mode');
          this.saveState();
          try { localStorage.setItem('pt_mode', this.state.marginMode); } catch(_) {}
        }

        const levBtn = e.target.closest('.lev');
        if (levBtn) {
          sidebar.querySelectorAll('.lev').forEach((b) => b.classList.remove('active'));
          levBtn.classList.add('active');
          this.state.leverage = Number(levBtn.getAttribute('data-lev')) || 15;
          this.saveState();
          this.updateCostPreview();
        }
      });

      if (this.el.percent) {
        this.el.percent.step = '1';
        this.el.percent.addEventListener('input', () => this.updateAmountFromPercent());
      }
      this.el.amount && this.el.amount.addEventListener('input', () => this.validateAndPreviewAmount());
      if (this.el.amountPercent) {
        this.el.amountPercent.addEventListener('input', () => this.updatePercentFromText());
      }
      if (this.el.price) {
        const onPriceInput = () => { this.priceTouched = true; this.updateCostPreview(); };
        this.el.price.addEventListener('input', onPriceInput);
        this.el.price.addEventListener('change', onPriceInput);
      }
      // priceType select Ï†úÍ±∞Ïóê Îî∞Îùº change Î¶¨Ïä§ÎÑà ÏÇ≠Ï†ú

      this.el.btnLong && this.el.btnLong.addEventListener('click', () => this.handleActionClick('long'));
      this.el.btnShort && this.el.btnShort.addEventListener('click', () => this.handleActionClick('short'));
      this.el.btnCloseAll && this.el.btnCloseAll.addEventListener('click', () => {
        if (!this._risk) this._risk = new window.RiskFunding({ getState: ()=>this.state, getBrackets: ()=>this._mmrBrackets });
        if (!this._ui) { this._ui = new window.UIRenderer(); this._ui.setFormat((n)=>this.format(n)); }
        if (!this._orders) this._orders = new window.OrderEngine(this.state, this._risk, this._ui);
        const cnt = this._orders.closeAll(this.state.lastPrice);
        if (cnt>0) { this.saveState(); this.renderPositions(); this.updateCostPreview(); this.syncUserBalanceDebounced(); }
      });

      // Ï¥àÍ∏∞ Î†åÎçî Ïãú Î°úÏª¨ Ìè¨ÏßÄÏÖò Ï¶âÏãú ÌëúÏãú (ÏÉàÎ°úÍ≥†Ïπ® ÌõÑ Îπà ÏÉÅÌÉú Î∞©ÏßÄ)
      requestAnimationFrame(() => this.renderPositions());

      // Ïù∏ÎùºÏù∏ Î™®Îìú/Î†àÎ≤ÑÎ¶¨ÏßÄ Ïª®Ìä∏Î°§
      const btnCross = document.getElementById('btn-mode-cross');
      const btnIso = document.getElementById('btn-mode-isolated');
      const levPercent = document.getElementById('lev-percent');
      const levValue = document.getElementById('lev-value');
      // Ïù∏ÎùºÏù∏ Î™®Îìú/Î†àÎ≤ÑÎ¶¨ÏßÄ ÎèôÏûë
      const attach = () => {
        const c = document.getElementById('btn-mode-cross');
        const i = document.getElementById('btn-mode-isolated');
        const s = document.getElementById('lev-percent');
        const v = document.getElementById('lev-value');
        // load prefs
        try {
          const savedMode = localStorage.getItem('pt_mode');
          if (savedMode === 'cross' || savedMode === 'isolated') this.state.marginMode = savedMode;
          const savedLev = Number(localStorage.getItem('pt_lev'));
          if (isFinite(savedLev) && savedLev>=1 && savedLev<=200) this.state.leverage = savedLev;
          const savedPct = Number(localStorage.getItem('pt_percent'));
          if (isFinite(savedPct) && s) s.value = String(Math.max(0, Math.min(100, savedPct)));
        } catch(_) {}
        if (c && !c.__bound) {
          c.addEventListener('click', () => {
            this.state.marginMode = 'cross';
            c.classList.add('active');
            i && i.classList.remove('active');
            this.saveState();
            try { localStorage.setItem('pt_mode','cross'); } catch(_) {}
          });
          c.__bound = true;
        }
        if (i && !i.__bound) {
          i.addEventListener('click', () => {
            this.state.marginMode = 'isolated';
            i.classList.add('active');
            c && c.classList.remove('active');
            this.saveState();
            try { localStorage.setItem('pt_mode','isolated'); } catch(_) {}
          });
          i.__bound = true;
        }
        if (s && !s.__bound) {
          // percent 0~100 -> leverage 1~200 Îß§Ìïë
          const pctToLev = (p) => Math.round(1 + (199 * (p/100)));
          const levToPct = (l) => Math.round(((l-1)/199)*100);
          const initLev = this.state.leverage || 15;
          s.value = String(levToPct(initLev));
          if (v && v.tagName === 'INPUT') v.value = String(initLev);
          else if (v) v.textContent = `${initLev}x`;
          s.addEventListener('input', () => {
            const lev = pctToLev(Number(s.value||0));
            if (v && v.tagName === 'INPUT') v.value = String(lev); else if (v) v.textContent = `${lev}x`;
            // Î†àÎ≤ÑÎ¶¨ÏßÄ Î≥ÄÍ≤Ω Ïãú ÏàòÎüâ/ÏòàÏÉÅÌëúÍ∏∞ ÎèôÍ∏∞Ìôî
            this.state.leverage = lev;
            this.updateAmountFromPercent();
            this.updateActionButtonsEnabled();
            try { localStorage.setItem('pt_lev', String(lev)); localStorage.setItem('pt_percent', String(s.value||'0')); } catch(_) {}
            // a11y
            s.setAttribute('aria-valuemin','0');
            s.setAttribute('aria-valuemax','100');
            s.setAttribute('aria-valuenow', String(s.value||'0'));
          });
          s.addEventListener('change', () => {
            const lev = pctToLev(Number(s.value||0));
            this.state.leverage = lev;
            this.saveState();
            this.updateAmountFromPercent();
            this.updateCostPreview();
            this.updateActionButtonsEnabled();
            try { localStorage.setItem('pt_lev', String(lev)); localStorage.setItem('pt_percent', String(s.value||'0')); } catch(_) {}
          });
          s.__bound = true;
        }
        // ÏûÖÎ†• Î∞ïÏä§ÏóêÏÑú ÏßÅÏ†ë Î≥ÄÍ≤Ω
        if (v && !v.__bound && v.tagName === 'INPUT') {
          const pctFromLev = (lev) => Math.round(((lev-1)/199)*100);
          v.addEventListener('input', () => {
            let lv = Math.max(1, Math.min(200, Number(v.value||0)));
            if (!isFinite(lv)) return;
            this.state.leverage = lv;
            this.saveState();
            if (s) s.value = String(pctFromLev(lv));
            this.updateAmountFromPercent();
            this.updateCostPreview();
            this.updateActionButtonsEnabled();
            try { localStorage.setItem('pt_lev', String(lv)); localStorage.setItem('pt_percent', String(s?s.value:'0')); } catch(_) {}
          });
          v.__bound = true;
        }
      };
      attach();
      const observer = new MutationObserver(attach);
      observer.observe(document.body, { childList: true, subtree: true });

      // Ïò§ÎçîÎ∂Å Ìà¥ÌåÅ (ÏúÑÏûÑ)
      const rowsEl = document.getElementById('orderbook-rows');
      if (rowsEl && !rowsEl.__tooltipBound) {
        const tt = this.ensureObTooltip();
        const show = (ev, row) => {
          const total = row?.getAttribute('data-cum-size');
          const notion = row?.getAttribute('data-cum-notional');
          if (!total || !notion) { tt.style.display = 'none'; return; }
          tt.innerHTML = `<div>ÎàÑÏ†Å ÏàòÎüâ: <b>${Number(total).toFixed(4)} BTC</b></div><div>Î™ÖÎ™©Í∞Ä: <b>${this.format(Number(notion))} USDT</b></div>`;
          tt.style.display = 'block';
          const x = ev.clientX + 12;
          const y = ev.clientY + 12;
          tt.style.left = x + 'px';
          tt.style.top = y + 'px';
        };
        rowsEl.addEventListener('mousemove', (e) => {
          const row = e.target.closest && e.target.closest('.ob-row.ask, .ob-row.bid');
          if (!row) { tt.style.display = 'none'; return; }
          show(e, row);
        });
        rowsEl.addEventListener('mouseleave', () => { tt.style.display = 'none'; });
        rowsEl.__tooltipBound = true;
      }

      // Ïò§ÎçîÎ∂Å Í∞ÄÍ≤© ÌÅ¥Î¶≠ ‚Üí Í∞ÄÍ≤© ÏûÖÎ†• ÏûêÎèô Ï±ÑÏö∞Í∏∞ (ÏúÑÏûÑ)
      if (rowsEl && !rowsEl.__priceClickBound) {
        rowsEl.addEventListener('click', (e) => {
          const row = e.target.closest && e.target.closest('.ob-row.ask, .ob-row.bid');
          if (!row) return;
          const priceAttr = row.getAttribute('data-price');
          const priceVal = Number(priceAttr);
          if (!isFinite(priceVal) || priceVal <= 0) return;
          if (!this.el || !this.el.price) return;

          // ÎßàÏºì Î™®ÎìúÏù∏ Í≤ΩÏö∞ LimitÎ°ú Ï†ÑÌôòÌïòÏó¨ Í∞ÄÍ≤© ÏûÖÎ†• Í∞ÄÎä• ÏÉÅÌÉúÎ°ú Î≥ÄÍ≤Ω
          if (this.el.price.disabled) {
            try {
              const sidebarEl = document.getElementById('paper-trading-sidebar');
              if (sidebarEl) {
                sidebarEl.querySelectorAll('.order-type').forEach((b) => b.classList.remove('active'));
                const limitBtn = sidebarEl.querySelector('.order-type[data-type="limit"]');
                if (limitBtn) limitBtn.classList.add('active');
              }
              const form = document.getElementById('order-form');
              if (form) form.classList.remove('is-market');
              this.el.price.disabled = false;
              this.el.price.placeholder = '';
            } catch(_) {}
          }

          this.el.price.value = String(priceVal);
          this.priceTouched = true;
          this.updateCostPreview();
        });
        rowsEl.__priceClickBound = true;
      }

      // Ï†ÑÏó≠ ÌÅ¥Î¶≠ ÏúÑÏûÑ: Limit/Market + Î™®Îã¨ Î≤ÑÌäºÎì§(ÍµêÏ∞®/Î†àÎ≤ÑÎ¶¨ÏßÄ)
      if (!window.__pt_globalBound) {
        document.addEventListener('click', (ev) => {
          // trade-tab Ï†úÍ±∞Îê®

          const typeBtn = ev.target.closest && ev.target.closest('.order-type');
          if (typeBtn) {
            document.querySelectorAll('.trade-panel .order-type').forEach(b => b.classList.remove('active'));
            typeBtn.classList.add('active');
            const t = typeBtn.getAttribute('data-type');
            if (this.el.price) {
              const isMkt = t === 'market';
              this.el.price.disabled = isMkt;
              const form = document.getElementById('order-form');
              if (form) form.classList.toggle('is-market', isMkt);
              this.el.price.placeholder = isMkt ? 'Fill at market price' : '';
              if (!isMkt && !this.priceTouched && !this.el.price.value) this.el.price.value = (this.state.lastPrice || 0).toFixed(1);
            }
            this.updateCostPreview();
          }

          // Î™®Îã¨ Ï†úÍ±∞Îê®
          const posTab = ev.target.closest && ev.target.closest('.pos-tab');
          if (posTab) {
            document.querySelectorAll('.pos-tab').forEach(b=>b.classList.remove('active'));
            posTab.classList.add('active');
            const key = posTab.getAttribute('data-pos-tab');
            const posTable = document.querySelector('.positions-table');
            const ordTable = document.querySelector('.orders-table');
            const hisTable = document.querySelector('.history-table');
            if (key === 'orders') {
              posTable && (posTable.style.display = 'none');
              ordTable && (ordTable.style.display = 'block');
              hisTable && (hisTable.style.display = 'none');
              this.renderOrders();
            } else if (key === 'history') {
              posTable && (posTable.style.display = 'none');
              ordTable && (ordTable.style.display = 'none');
              hisTable && (hisTable.style.display = 'block');
              this.renderHistory && this.renderHistory();
            } else {
              posTable && (posTable.style.display = 'block');
              ordTable && (ordTable.style.display = 'none');
              hisTable && (hisTable.style.display = 'none');
            }
            return;
          }
        });
        window.__pt_globalBound = true;
      }
    }

    // ===============================
    // Auth Ïó∞Îèô: ÌöåÏõê ÏûîÍ≥† Ïó∞Îèô + ÎπÑÌöåÏõê Ï∞®Îã®
    // ===============================
    initAuthIntegration() {
      // Firebase auth ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïó∞Í≤∞
      try {
        if (window.auth && typeof window.auth.onAuthStateChanged === 'function') {
          window.auth.onAuthStateChanged((user) => this.onAuthChanged(user));
        } else {
          // Ï¥àÍ∏∞ Î°úÎìú ÏßÄÏó∞ ÎåÄÎπÑ: Ïû†Ïãú ÌõÑ Ïû¨ÏãúÎèÑ
          setTimeout(() => this.initAuthIntegration(), 300);
        }
      } catch (_) {}

      // ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏(ÌîÑÎ°úÌïÑ/ÌïÑÎìú Î≥ÄÍ≤Ω) ÏàòÏã†
      window.addEventListener('userDataUpdated', (e) => {
        const d = e && e.detail && e.detail.user;
        if (d && this.user && d.uid === this.user.uid) {
          // ÌïÑÏöî Ïãú Ï∂îÍ∞Ä ÌïÑÎìú Î∞òÏòÅ Í∞ÄÎä•
        }
      });
    }

    async onAuthChanged(user) {
      this.user = user || null;
      if (!this.user) {
        // ÎπÑÌöåÏõê: Í±∞Îûò Ï∞®Îã® + UI ÎπÑÌôúÏÑ±Ìôî + ÏûîÍ≥† 0 ÌëúÏãú (Î°úÏª¨ Ï†ÄÏû•ÏùÄ ÌïòÏßÄ ÏïäÏùå)
        this.guestLocked = true;
        this.setBalanceInMemory(0, { persist: false });
        // Î°úÍ∑∏ÏïÑÏõÉ Ïãú Î°úÏª¨ Ìè¨ÏßÄÏÖò/Ïò§Îçî/ÌûàÏä§ÌÜ†Î¶¨ Î∞è Ï†ÄÏû• ÏÉÅÌÉú ÏôÑÏ†Ñ Ï¥àÍ∏∞Ìôî
        this.clearTradingStateOnLogout();
        this.updateAuthLockUI(true);
        return;
      }

      // ÌöåÏõê: Í±∞Îûò ÌóàÏö©, ÏÑúÎ≤Ñ ÏûîÍ≥† Î°úÎìú/ÎèôÍ∏∞Ìôî
      this.guestLocked = false;
      this.updateAuthLockUI(false);
      await this.loadUserBalanceFromFirestore();
      try { window.onbitMiner && window.onbitMiner.setUser(this.user); } catch(_) {}
    }

    clearTradingStateOnLogout() {
      try { localStorage.removeItem(STORAGE_KEY); } catch(_) {}
      // ÎÇ¥Î∂Ä ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      this.state.positions = [];
      this.state.openOrders = [];
      this.state.history = [];
      this.state.balanceUSDT = 0;
      this.state.equityUSDT = 0;
      // ÏûÖÎ†•Í∞í/ÌîåÎûòÍ∑∏ Ï¥àÍ∏∞Ìôî
      try { if (this.el && this.el.amount) this.el.amount.value = ''; } catch(_) {}
      this.priceTouched = false;
      // UI Ï¶âÏãú Î∞òÏòÅ
      try { this.renderPositions(); } catch(_) {}
      try { this.renderOrders(); } catch(_) {}
      try { this.renderAccountPanel(); } catch(_) {}
      try { this.renderHistory && this.renderHistory(); } catch(_) {}
    }

    updateAuthLockUI(locked) {
      const disable = (el, flag) => { if (el) el.disabled = !!flag; };
      disable(this.el.amount, locked);
      disable(this.el.price, locked || (document.querySelector('.order-type.active')?.dataset.type === 'market'));
      disable(this.el.percent, locked);
      disable(this.el.btnLong, locked);
      disable(this.el.btnShort, locked);
      // ÌëúÏãúÏö© ÏûîÍ≥† ÌÖçÏä§Ìä∏
      if (this.el.balance) this.el.balance.textContent = locked ? '0' : this.format(this.state.balanceUSDT);
      // trade-panel Ï†ÑÏ≤¥Ïóê ÌÅ¥ÎûòÏä§ ÌÜ†Í∏Ä(ÏÑ†ÌÉùÏ†ÅÏúºÎ°ú Ïä§ÌÉÄÏùºÎßÅ Í∞ÄÎä•)
      const panel = document.querySelector('.trade-panel');
      if (panel) panel.classList.toggle('locked', !!locked);
    }

    setBalanceInMemory(value, { persist = true } = {}) {
      this.state.balanceUSDT = Math.max(0, Number(value) || 0);
      if (persist && !this.guestLocked) this.saveState();
      this.renderAccountPanel();
      this.updateCostPreview();
    }

    async loadUserBalanceFromFirestore() {
      try {
        if (!window.db || !this.user) return;
        const ref = window.db.collection('users').doc(this.user.uid);
        const snap = await ref.get();
        const data = snap && (typeof snap.data === 'function' ? snap.data() : snap.data);
        const pt = data && data.paperTrading;
        if (pt && typeof pt.balanceUSDT === 'number' && isFinite(pt.balanceUSDT)) {
          this.setBalanceInMemory(pt.balanceUSDT, { persist: true });
        } else {
          // ÏÑúÎ≤ÑÏóê Ï¥àÍ∏∞Í∞í Í∏∞Î°ù (Î°úÏª¨ ÏÉÅÌÉú Í∏∞Ï§Ä)
          await ref.set({ paperTrading: { balanceUSDT: this.state.balanceUSDT, equityUSDT: this.state.equityUSDT || this.state.balanceUSDT } }, { merge: true });
        }
      } catch (_) {}
    }

    syncUserBalanceDebounced() {
      if (!this.user || !window.db) return;
      clearTimeout(this._syncTimer);
      this._syncTimer = setTimeout(() => this.syncUserBalance(), 1200); // Ïø®Îã§Ïö¥ 1.2s
    }

    async syncUserBalance() {
      if (!this.user || !window.db) return;
      let attempts = 0;
      let delay = 400;
      while (attempts < 5) {
        try {
          await window.db.collection('users').doc(this.user.uid).set({
            paperTrading: {
              balanceUSDT: this.state.balanceUSDT,
              equityUSDT: this.state.equityUSDT
            }
          }, { merge: true });
          return;
        } catch (e) {
          attempts++;
          await new Promise(r => setTimeout(r, delay));
          delay = Math.min(10000, delay * 2);
        }
      }
    }

    handleActionClick(side) {
      // Îã®Ïùº Î™®Îìú: Ìï≠ÏÉÅ Ïã†Í∑ú Ïò§Îçî
      if (!this.user) {
        alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§. ÌöåÏõêÎßå Í±∞ÎûòÌï† Ïàò ÏûàÏäµÎãàÎã§.');
        return;
      }
      this.placeOrder(side);
    }

    // Close/Î∂ÄÎ∂ÑÏ≤≠ÏÇ∞ Î°úÏßÅ Ï†úÍ±∞Îê® (Îã®Ïùº Ïò§Ìîà Î™®Îìú)

    start() {
      // MarketSockets ÏÇ¨Ïö©. Ï¥àÍ∏∞ REST 1ÌöåÎßå ÏàòÌñâ
      this.fetchInitialPrice();
    }

    stop() {
      if (this.priceTimer) clearInterval(this.priceTimer);
    }

    setSymbol(sym) {
      if (!sym) return;
      const compact = sym.replace(/[-:]/g, '').replace(/USDTUSDT/, 'USDT');
      this.state.symbol = compact.endsWith('USDT') ? compact : compact + 'USDT';
      this.el.symbol.textContent = this.state.symbol;
      this.market?.addSymbol?.(this.state.symbol);
      this.saveState();
      this.market.setSymbol(this.state.symbol);
      this.renderDepth();
      // Í∞ÄÍ≤© ÏÜåÏºìÏùÄ MarketSocketsÍ∞Ä Í¥ÄÎ¶¨
      this.priceTouched = false;
      this.fetchInitialPrice();
      // Ïã¨Î≥º Î≥ÄÍ≤Ω Ïãú Ïú†ÏßÄÏ¶ùÍ±∞Í∏à Î∏åÎûòÌÇ∑ Í∞±Ïã†
      this.fetchLeverageBrackets();
    }

    getActivePrice() {
      if (this.el.price.disabled) return this.state.lastPrice;
      const p = Number(this.el.price.value);
      return p > 0 ? p : this.state.lastPrice;
    }

    updateAmountFromPercent() {
      // ÏûêÏÇ∞(ÏßÄÍ∞ë ÏûîÍ≥†)Ïùò ÌçºÏÑºÌä∏Î•º Í∏∞Î∞òÏúºÎ°ú ÏàòÎüâ Í≥ÑÏÇ∞
      const percent = Number(this.el.percent.value) / 100;
      const price = this.getActivePrice();
      const lev = this.state.leverage;
      const wallet = Math.max(0, this.state.balanceUSDT);
      const cost = wallet * percent; // Ìà¨ÏûÖ Ï¶ùÍ±∞Í∏à
      const amount = (cost * lev) / Math.max(1e-8, price);
      if (this.el.amount) {
        // ÏàòÎüâ Ìã± Ïä§ÎÉÖ
        const snapped = Math.round(this.toAmount(amount) / AMOUNT_TICK) * AMOUNT_TICK;
        this.el.amount.value = this.toAmount(snapped);
      }
      if (this.el.amountPercent) this.el.amountPercent.value = `${Math.round((percent)*100)}%`;
      this.validateAndPreviewAmount();
      this.updateActionButtonsEnabled();
    }

    updatePercentFromText() {
      const raw = (this.el.amountPercent?.value || '').toString();
      // Í≥µÎ∞±/Î¨∏Ïûê Ï†úÍ±∞ ‚Üí Ïà´ÏûêÎßå Ï∂îÏ∂ú
      const cleaned = raw.replace(/[^0-9.]/g, '');
      let p = Number(cleaned);
      if (!isFinite(p)) return;
      p = Math.max(0, Math.min(100, p));
      if (this.el.percent) this.el.percent.value = String(p);
      // Ïä¨ÎùºÏù¥Îçî Î≥ÄÌôîÏôÄ ÎèôÏùº Í≥ÑÏÇ∞ Ïû¨ÏÇ¨Ïö©
      this.updateAmountFromPercent();
      // ÌëúÍ∏∞ Ï†ïÍ∑úÌôî
      if (this.el.amountPercent) this.el.amountPercent.value = `${p}%`;
      this.updateActionButtonsEnabled();
    }

    validateAndPreviewAmount() {
      const err = document.getElementById('pt-amount-error');
      const wrap = this.el.amount && this.el.amount.closest('.input-wrap');
      const amt = Number(this.el.amount?.value || 0);
      if (!isFinite(amt) || amt <= 0) {
        if (wrap) wrap.classList.add('error');
        if (err) err.style.display = '';
      } else {
        if (wrap) wrap.classList.remove('error');
        if (err) err.style.display = 'none';
      }
      this.updateCostPreview();
    }

    updateActionButtonsEnabled() {
      const p = Number(this.el.percent?.value || 0);
      const amt = Number(this.el.amount?.value || 0);
      const disabled = this.guestLocked || !isFinite(p) || p <= 0 || !isFinite(amt) || amt <= 0;
      if (this.el.btnLong) this.el.btnLong.disabled = disabled;
      if (this.el.btnShort) this.el.btnShort.disabled = disabled;
    }

    updateCostPreview() {
      const price = this.getActivePrice();
      const amt = Number(this.el.amount.value || 0);
      const lev = this.state.leverage;
      // ÌçºÏÑºÌä∏Í∞Ä ÏûàÏúºÎ©¥ ÌçºÏÑºÌä∏ Í∏∞Î∞ò ÎπÑÏö© ÌëúÏãú(Î†àÎ≤ÑÎ¶¨ÏßÄÏôÄ Î¨¥Í¥ÄÌïòÍ≤å Ìà¨ÏûÖ Ï¶ùÍ±∞Í∏à)
      let cost;
      const pStr = this.el.percent && this.el.percent.value;
      const pNum = Number(pStr);
      if (this.el.percent && isFinite(pNum)) {
        const wallet = Math.max(0, this.state.balanceUSDT);
        cost = wallet * (pNum/100);
      } else {
        // ÌçºÏÑºÌä∏ Î∂àÎ™ÖÌôï Ïãú ÏàòÎüâ Í∏∞Î∞ò Í≥ÑÏÇ∞
        cost = price * amt / lev;
      }
      if (this.el.balance) this.el.balance.textContent = this.format(this.state.balanceUSDT);
      if (this.el.cost) this.el.cost.textContent = this.format(cost);

      // ÏàòÏàòÎ£å ÎØ∏Î¶¨Î≥¥Í∏∞ (Í∏∞Î≥∏: ÌÖåÏù¥Ïª§ ÏàòÏàòÎ£å Í∏∞Ï§Ä)
      try {
        const notional = Math.max(0, price * amt);
        const makerRate = (window.CONFIG?.fees?.maker ?? 0.00025); // 0.025%
        const takerRate = (window.CONFIG?.fees?.taker ?? 0.0006);  // 0.06%
        const makerFee = notional * makerRate;
        const takerFee = notional * takerRate;
        const isMarket = this.el.price && this.el.price.disabled;
        const basis = isMarket ? `Taker (ÏãúÏû•Í∞Ä) ‚Äî ${(takerRate*100).toFixed(3)}%` : `Maker (ÏßÄÏ†ïÍ∞Ä) ‚Äî ${(makerRate*100).toFixed(3)}%`;
        const fee = isMarket ? takerFee : makerFee;
        if (this.el.feeBasis) this.el.feeBasis.textContent = basis;
        if (this.el.feeEstimate) this.el.feeEstimate.textContent = this.format(fee);
      } catch(_) {}
    }

    // Close Í¥ÄÎ†® Î≥¥Ï°∞Ìï®Ïàò Ï†úÍ±∞Îê®

    placeOrder(side) {
      if (!this.user) {
        alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§. ÌöåÏõêÎßå Í±∞ÎûòÌï† Ïàò ÏûàÏäµÎãàÎã§.');
        return;
      }
      const amt = Number(this.el.amount.value || 0);
      if (!isFinite(amt) || amt <= 0) { alert('Ïò¨Î∞îÎ•∏ ÏàòÎüâÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.'); return; }
      if (amt <= 0) return alert('ÏàòÎüâÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
      const isMarket = this.el.price.disabled;
      const price = this.getActivePrice();
      if (!isFinite(price) || price <= 0) { alert('Ïò¨Î∞îÎ•∏ Í∞ÄÍ≤©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.'); return; }
      const lev = this.state.leverage;
      if (isMarket) {
        // OrderEngine Í≤ΩÎ°úÎ°ú Ïö∞ÏÑ† ÏãúÎèÑ
        if (window.RiskFunding && window.OrderEngine && window.UIRenderer) {
          if (!this._risk) this._risk = new window.RiskFunding({ getState: ()=>this.state, getBrackets: ()=>this._mmrBrackets });
          if (!this._ui) { this._ui = new window.UIRenderer(); this._ui.setFormat((n)=>this.format(n)); }
          if (!this._orders) this._orders = new window.OrderEngine(this.state, this._risk, this._ui);
          const ok = this._orders.placeMarket(side, price, amt);
          if (ok) {
            this.saveState();
            this.syncUserBalance();
            this.renderPositions();
            this.updateCostPreview();
            this.el.amount.value = '';
            this.syncUserBalanceDebounced();
            this.showCenterOrderMessage('order successfully placed');
            return;
          }
        }
        const margin = price * amt / lev;
        const openNotional = price * amt;
        const openFee = openNotional * FEE_TAKER;
        if (margin + openFee > this.state.balanceUSDT + 1e-8) return alert('Í∞ÄÏö© ÏûêÏÇ∞Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.');
        const pos = {
          id: 'pos_' + Date.now(),
          symbol: this.state.symbol,
          side,
          entry: price,
          amount: amt,
          leverage: lev,
          margin,
          mode: this.state.marginMode,
        };
        this.state.balanceUSDT -= (margin + openFee);
        this.state.positions.push(pos);
        this.saveState();
        this.syncUserBalance(); // Ï≤¥Í≤∞ Ï¶âÏãú 1Ìöå ÎèôÍ∏∞Ìôî
        // historyÎäî OrderEngineÏóê ÏúÑÏûÑÎê®
        try { window.TradeNotifier && window.TradeNotifier.notify({
          title: `Open ${side==='long'?'Long':'Short'} ${this.state.symbol} ${this.state.marginMode==='cross'?'Cross':'Isolated'} ¬∑ ${this.state.leverage}x`,
          subtitle: 'Perp ¬∑ Filled',
          price,
          amount: amt,
          mode: this.state.marginMode,
          leverage: this.state.leverage,
          type: 'success',
        }); } catch(_) {}
        this.renderPositions();
        this.updateCostPreview();
        this.el.amount.value = '';
        this.syncUserBalanceDebounced();
        this.showCenterOrderMessage('order successfully placed');
      } else {
        if (!this._risk) this._risk = new window.RiskFunding({ getState: ()=>this.state, getBrackets: ()=>this._mmrBrackets });
        if (!this._ui) { this._ui = new window.UIRenderer(); this._ui.setFormat((n)=>this.format(n)); }
        if (!this._orders) this._orders = new window.OrderEngine(this.state, this._risk, this._ui);
        const order = this._orders.placeLimit(side, price, amt);
        this.saveState();
        this.syncUserBalance(); // Ï¶âÏãú ÎèôÍ∏∞Ìôî
        this.renderOrders();
        this.el.amount.value = '';
        // ÏïåÎ¶º Ï∞Ω Ï†úÍ±∞ (ÏöîÏ≤≠)
        if (order) this.showCenterOrderMessage('order successfully placed');
      }
    }

    closePosition(id) {
      const idx = this.state.positions.findIndex((p) => p.id === id);
      if (idx === -1) return;
      const p = this.state.positions[idx];
      const price = this.state.lastPrice || p.entry;
      const pnl = this.calcPnL(p, price);
      const closeFee = Math.max(0, price * p.amount * FEE_TAKER);
      this.state.balanceUSDT += Math.max(0, p.margin + pnl - closeFee);
      this.state.positions.splice(idx, 1);
      this.saveState();
      // history record - Market Close
      this.state.history.unshift({ id:'his_'+Date.now(), ts:Date.now(), symbol:p.symbol, mode:p.mode, leverage:p.leverage, direction: p.side==='long'?'Close Long':'Close Short', type:'Market', avgPrice:price, orderPrice:price, filled:p.amount, fee: closeFee, pnl });
      if (this.state.history.length>500) this.state.history.length=500;
      // ONBIT Ï±ÑÍµ¥: ÏàòÏùµ/ÏÜêÏã§ Î™®Îëê Í∑úÏπôÏóê Îî∞Îùº Ï†ÅÎ¶Ω (Ïã§ÏãúÍ∞Ñ ÏûîÍ≥† Í∞±Ïã† Ïù¥Î≤§Ìä∏ Î∞úÏÉù)
      try { if (window.onbitMiner && this.user && pnl !== 0) {
        window.onbitMiner.awardForProfit(pnl);
      } } catch(_) {}
      try { window.TradeNotifier && window.TradeNotifier.notify({
        title: `Close ${p.side==='long'?'Long':'Short'} ${p.symbol} ${p.mode==='cross'?'Cross':'Isolated'} ¬∑ ${p.leverage}x`,
        subtitle: 'Market ¬∑ Filled',
        price,
        amount: p.amount,
        mode: p.mode,
        leverage: p.leverage,
        type: pnl>=0?'success':'warn',
      }); } catch(_) {}
      this.renderPositions();
      this.updateCostPreview();
      this.syncUserBalanceDebounced();
    }

    closeAll() {
      const price = this.state.lastPrice;
      const closed = [...this.state.positions];
      let total = 0;
      for (const p of closed) {
        const pnl = this.calcPnL(p, price);
        const closeFee = Math.max(0, price * p.amount * FEE_TAKER);
        total += Math.max(0, p.margin + pnl - closeFee);
        // history per position
        this.state.history.unshift({ id:'his_'+Date.now()+Math.random(), ts:Date.now(), symbol:p.symbol, mode:p.mode, leverage:p.leverage, direction: p.side==='long'?'Close Long':'Close Short', type:'Market', avgPrice:price, orderPrice:price, filled:p.amount, fee: closeFee, pnl });
        if (this.state.history.length>500) this.state.history.length=500;
        // notify per position
        try { window.TradeNotifier && window.TradeNotifier.notify({
          title: `Close ${p.side==='long'?'Long':'Short'} ${p.symbol} ${p.mode==='cross'?'Cross':'Isolated'} ¬∑ ${p.leverage}x`,
          subtitle: 'Market ¬∑ Filled',
          price,
          amount: p.amount,
          mode: p.mode,
          leverage: p.leverage,
          type: pnl>=0?'success':'warn',
        }); } catch(_) {}
        // ONBIT Ï±ÑÍµ¥ (Î∞∞Ïπò Ï≤≠ÏÇ∞ÏóêÏÑúÎèÑ Í∞Å Ìè¨ÏßÄÏÖòÎ≥Ñ Ï†ÅÏö©)
        try { if (window.onbitMiner && this.user && pnl !== 0) {
          window.onbitMiner.awardForProfit(pnl);
        } } catch(_) {}
      }
      this.state.balanceUSDT += total;
      this.state.positions = [];
      this.saveState();
      this.renderPositions();
      this.updateCostPreview();
      this.syncUserBalanceDebounced();
    }

    calcPnL(p, price) {
      const diff = p.side === 'long' ? price - p.entry : p.entry - price;
      return diff * p.amount;
    }

    calcEffectiveLeverage(p) {
      // Í≤©Î¶¨: Ïã§Ï†ú ÎßàÏßÑ Í∏∞Ï§Ä, ÍµêÏ∞®: Í∞ÄÏö© ÏûîÍ≥†Î°ú Ïú†ÏßÄÏ¶ùÍ±∞Í∏à Î≥¥Í∞ï
      const notional = p.entry * p.amount;
      if (p.mode === 'isolated') {
        const im = Math.max(1e-8, p.margin);
        return Math.max(1, notional / im);
      } else {
        const crossMargin = Math.max(1e-8, p.margin + Math.max(0, this.state.balanceUSDT));
        return Math.max(1, notional / crossMargin);
      }
    }

    calcLiqPrice(p) {
      // Ïú†ÏßÄÏ¶ùÍ±∞Í∏à = notional(price) √ó mmr
      // Í∞ÄÏö©ÏûêÍ∏à(available) = (Í≤©Î¶¨) p.margin + uPnL(price) - fee(price)
      //                     = (ÍµêÏ∞®) (p.margin + wallet) + uPnL(price) - fee(price)
      // Î°± uPnL(price) = (price - entry) * amount
      // Ïàè uPnL(price) = (entry - price) * amount
      // fee(price) ‚âà notional(price) √ó taker_fee (Î≥¥ÏàòÏ†Å Ï∂îÏ†ï)
      //
      // Î°± Í≤©Î¶¨: p.margin + (P - e)A - f P A = mmr P A
      //   => p.margin - eA + P A (1 - f - mmr) = 0
      //   => P = (eA - p.margin) / (A (1 - f - mmr))
      // Ïàè Í≤©Î¶¨: p.margin + (e - P)A - f P A = mmr P A
      //   => p.margin + eA = P A (1 + f + mmr)
      //   => P = (p.margin + eA) / (A (1 + f + mmr))
      // ÍµêÏ∞®Îäî p.margin ÎåÄÏã† (p.margin + wallet)ÏùÑ ÏÇ¨Ïö© (Í∞ÑÏù¥ Í∑ºÏÇ¨)
      try {
        const e = Number(p.entry);
        const A = Math.max(1e-12, Number(p.amount));
        const f = Number(FEE_TAKER);
        const mmr = Number(this.getMaintenanceRate(p));
        const wallet = Math.max(0, this.state.balanceUSDT || 0);
        const base = p.mode === 'isolated' ? Number(p.margin) : Number(p.margin) + wallet;
        const denomLong = A * (1 - f - mmr);
        const denomShort = A * (1 + f + mmr);
        if (p.side === 'long') {
          if (denomLong > 1e-12) {
            const P = (e * A - base) / denomLong;
            if (isFinite(P) && P > 0) return P;
          }
        } else {
          if (denomShort > 1e-12) {
            const P = (base + e * A) / denomShort;
            if (isFinite(P) && P > 0) return P;
          }
        }
        // Fallback: Ïú†Ìö®ÌïòÏßÄ ÏïäÏúºÎ©¥ Ïú†Ìö®Î†àÎ≤ÑÎ¶¨ÏßÄ Í∏∞Î∞ò Í∞ÑÎã® Í∑ºÏÇ¨Ïãù ÏÇ¨Ïö©
        const Lf = Math.max(1.0001, Number(p.leverage) || 1);
        if (p.side === 'long') return Math.max(1e-6, e * (1 - 1 / Lf));
        return Math.max(1e-6, e * (1 + 1 / Lf));
      } catch (_) { return NaN; }
    }

    getMaintenanceRate(p) {
      // 1) Ïã§Îç∞Ïù¥ÌÑ∞ Î∏åÎûòÌÇ∑ Ïö∞ÏÑ† ÏÇ¨Ïö© (Î™ÖÎ™©Í∞Ä ÏÉÅÌïú cap Í∏∞Ï§Ä)
      try {
        if (this._mmrBrackets && this._mmrBrackets.length) {
          const notional = Math.max(0, (this.state.lastPrice || p.entry) * p.amount);
          let mmr = this._mmrBrackets[0].mmr;
          for (const b of this._mmrBrackets) {
            if (!isFinite(b.cap) || b.cap <= 0) { mmr = b.mmr; break; }
            if (notional <= b.cap) { mmr = b.mmr; break; }
            mmr = b.mmr; // ÎÑòÏñ¥Í∞ÄÎ©¥ Îã§Ïùå Ìã∞Ïñ¥Î°ú Í∞±Ïã†
          }
          if (isFinite(mmr) && mmr > 0) return mmr;
        }
      } catch (_) {}
      // 2) Ìè¥Î∞±: Î†àÎ≤ÑÎ¶¨ÏßÄ Í∏∞Î∞ò Í∑ºÏÇ¨ (0.25%~0.8%)
      const L = Math.max(1, p.leverage);
      const initialMarginRate = 1 / L;
      const scaled = initialMarginRate * 0.6;
      return Math.max(0.0025, Math.min(0.008, scaled));
    }

    updatePnL() {
      const now = performance.now();
      this.state.equityUSDT = this.state.balanceUSDT + this.state.positions.reduce((acc, p) => acc + this.calcPnL(p, this.state.lastPrice), 0);
      // Limit Ï≤¥Í≤∞ Îß§Ïπ≠ÏùÑ OrderEngineÎ°ú ÏúÑÏûÑ
      if (!this._risk) this._risk = new (window.RiskFunding||function(){})({ getState: ()=>this.state, getBrackets: ()=>this._mmrBrackets });
      if (!this._ui) { this._ui = new (window.UIRenderer||function(){})(); this._ui.setFormat && this._ui.setFormat((n)=>this.format(n)); }
      if (!this._orders) this._orders = new (window.OrderEngine||function(){ })(this.state, this._risk, this._ui);
      const filled = this._orders.matchOpenOrders(this.state.lastPrice);
      if (filled > 0) {
        // Ïã†Í∑ú Ï≤¥Í≤∞ Ï¶âÏãú Î≥¥Ïú† Ìè¨ÏßÄÏÖò ÌÖåÏù¥Î∏î Ïû¨ÏÉùÏÑ±
        this.renderPositions();
      }
      // Ï≤≠ÏÇ∞ Ï≤¥ÌÅ¨ (Í∞ÄÍ≤© Î≥ÄÎèô Ïãú)
      const didLiq = this._risk.checkLiquidations ? this._risk.checkLiquidations() : this.checkLiquidations();
      if (didLiq) {
        this.renderPositions();
      }
      if (this._risk.applyFundingIfDue) {
        const changed = this._risk.applyFundingIfDue();
        if (changed) { this.saveState(); this.syncUserBalanceDebounced && this.syncUserBalanceDebounced(); }
      } else {
        this.applyFundingIfDue();
      }
      if (now - this._lastPnlRender > 150) { // 150ms Ïä§Î°úÌãÄ
        this._lastPnlRender = now;
        // Ìè¨ÏßÄÏÖò Í∏∞Î∞ò Ïã§ÏãúÍ∞Ñ Ï±ÑÍµ¥ ÏòàÏÉÅ ÎàÑÏ†Å ‚Üí ÏûîÍ≥† Ìå®ÎÑêÏóê Î∞òÏòÅ (UI ÌëúÏãúÏö©)
        try {
          let minedPreview = 0;
          for (const pos of this.state.positions) {
            const pnl = this.calcPnL(pos, this.state.lastPrice);
            const rate = pnl > 0 ? 1.0 : (pnl < 0 ? 0.1 : 0);
            minedPreview += Math.abs(pnl) * rate;
          }
          this._onbitPreview = minedPreview;
          const base = (typeof this._onbitBase === 'number') ? this._onbitBase : ((window.onbitMiner && Number.isFinite(window.onbitMiner.current)) ? Number(window.onbitMiner.current) : 0);
          const total = base + minedPreview;
          this.updateOnbitDisplay(total);
        } catch(_) {}
        this.renderPositionsValuesOnly();
        this.renderAccountPanel();
      }
    }

    updateOnbitDisplay(total) {
      try {
        const el = document.getElementById('acc-onbit');
        if (!el) return;
        const prev = (typeof el.__rollingPrev === 'number') ? el.__rollingPrev : Number(total || 0);
        el.__rollingPrev = Number(total || 0);
        this.animateNumber(el, prev, Number(total || 0), 600, (v)=> `${Number(v).toFixed(3)} ONBIT`);
        el.style.color = 'var(--primary-color)';
      } catch (_) {}
    }

    showCenterOrderMessage(text = 'order successfully placed') {
      try {
        let el = document.getElementById('center-order-msg');
        if (!el) {
          el = document.createElement('div');
          el.id = 'center-order-msg';
          el.setAttribute('aria-live', 'polite');
          el.style.position = 'fixed';
          el.style.left = '50%';
          el.style.top = '20%';
          el.style.transform = 'translate(-50%, -50%)';
          el.style.padding = '12px 18px';
          el.style.borderRadius = '10px';
          // ÌÖåÎßà Î≥ÄÏàò ÏÇ¨Ïö©
          el.style.background = 'var(--card-bg)';
          el.style.border = '1px solid var(--border-color)';
          el.style.color = 'var(--text-color)';
          el.style.fontWeight = '700';
          el.style.fontSize = '16px';
          el.style.boxShadow = '0 8px 24px rgba(0,0,0,0.15)';
          el.style.pointerEvents = 'none';
          el.style.opacity = '0';
          el.style.transition = 'opacity 200ms ease, transform 200ms ease';
          document.body.appendChild(el);
        }
        el.textContent = text;
        // show
        requestAnimationFrame(() => {
          el.style.opacity = '1';
          el.style.transform = 'translate(-50%, -50%) scale(1)';
        });
        // hide after 1.5s
        clearTimeout(el.__timer);
        el.__timer = setTimeout(() => {
          el.style.opacity = '0';
          el.style.transform = 'translate(-50%, -50%) scale(0.98)';
        }, 1500);
      } catch (_) {}
    }

    applyFundingIfDue() {
      const now = Date.now();
      if (!this.state.lastFundingTs) this.state.lastFundingTs = now;
      if (now - this.state.lastFundingTs < FUNDING_INTERVAL_MS) return;
      const rate = Number(this.state.fundingRate || 0);
      if (!isFinite(rate) || this.state.positions.length === 0) {
        this.state.lastFundingTs = now;
        return;
      }
      const mark = this.state.lastPrice || 0;
      let changed = false;
      for (const p of this.state.positions) {
        const notional = Math.max(0, mark * p.amount);
        if (notional <= 0) continue;
        const base = notional * Math.abs(rate);
        const flow = (rate > 0)
          ? (p.side === 'long' ? -base : +base)
          : (p.side === 'long' ? +base : -base);
        if (p.mode === 'isolated') {
          p.margin = Math.max(0, p.margin + flow);
        } else {
          this.state.balanceUSDT += flow;
        }
        this.state.history.unshift({ id:'his_'+Date.now()+Math.random(), ts:now, symbol:p.symbol, mode:p.mode, leverage:p.leverage, direction: 'Funding', type:'Funding', avgPrice:mark, orderPrice:mark, filled:p.amount, fee:0, pnl: flow });
        if (this.state.history.length>500) this.state.history.length=500;
        changed = true;
      }
      this.state.lastFundingTs = now;
      if (changed) {
        this.saveState();
        this.syncUserBalanceDebounced && this.syncUserBalanceDebounced();
      }
    }

    checkLiquidations() {
      let liqCount = 0;
      const mark = this.state.lastPrice || 0;
      const totalUPnL = this.state.positions.reduce((s, x) => s + this.calcPnL(x, mark), 0);
      const remain = [];
      for (const p of this.state.positions) {
        const notional = Math.max(0, mark * p.amount);
        const maintRate = this.getMaintenanceRate(p);
        const maintMargin = notional * maintRate;
        const feeEst = notional * FEE_TAKER;
        const pnl = this.calcPnL(p, mark);
        let available;
        if (p.mode === 'isolated') {
          available = p.margin + pnl - feeEst;
        } else {
          // ÍµêÏ∞®: ÏßÄÍ∞ë ÏûîÍ≥† + Ï†ÑÏ≤¥ uPnLÎ°ú Ï∂©Îãπ
          available = this.state.balanceUSDT + totalUPnL - feeEst;
        }
        const deficit = available - maintMargin;
        if (deficit < -1e-8) {
          // Ï≤≠ÏÇ∞: ÎßàÌÅ¨Í∞ÄÎ°ú Ï†ïÏÇ∞ Ï≤òÎ¶¨ + ÌûàÏä§ÌÜ†Î¶¨
          const liqFee = Math.max(0, mark * p.amount * FEE_TAKER);
          this.state.balanceUSDT += Math.max(0, p.margin + pnl - liqFee);
          this.state.history.unshift({ id:'his_'+Date.now(), ts:Date.now(), symbol:p.symbol, mode:p.mode, leverage:p.leverage, direction: 'Forced '+(p.side==='long'?'Long':'Short'), type:'Market', avgPrice:mark, orderPrice:mark, filled:p.amount, fee: liqFee, pnl });
          if (this.state.history.length>500) this.state.history.length=500;
          liqCount++;
        } else {
          remain.push(p);
        }
      }
      if (liqCount > 0) {
        this.state.positions = remain;
        this.saveState();
      }
      return liqCount;
    }

    matchOpenOrders() {
      if (!Array.isArray(this.state.openOrders) || this.state.openOrders.length === 0) return 0;
      const price = this.state.lastPrice || 0;
      const next = [];
      let filledCount = 0;
      for (const o of this.state.openOrders) {
        const shouldFill = (o.side === 'long') ? (price <= o.price + 1e-8) : (price >= o.price - 1e-8);
        if (shouldFill) {
          const margin = o.price * o.amount / o.leverage;
          const openNotional = o.price * o.amount;
          const openFee = openNotional * FEE_MAKER;
          if (margin + openFee > this.state.balanceUSDT + 1e-8) {
            // ÏûîÍ≥† Î∂ÄÏ°± Ïãú Ïú†ÏßÄ
            next.push(o);
            continue;
          }
          const pos = {
            id: 'pos_' + Date.now(),
            symbol: o.symbol,
            side: o.side,
            entry: o.price,
            amount: o.amount,
            leverage: o.leverage,
            margin,
            mode: o.mode,
          };
          this.state.balanceUSDT -= (margin + openFee);
          this.state.positions.push(pos);
          filledCount++;
          // history record - Limit Fill
          this.state.history.unshift({ id:'his_'+Date.now(), ts:Date.now(), symbol:o.symbol, mode:o.mode, leverage:o.leverage, direction: o.side==='long'?'Open Long':'Open Short', type:'Limit', avgPrice:o.price, orderPrice:o.price, filled:o.amount, fee: openFee, pnl:null });
          if (this.state.history.length>500) this.state.history.length=500;
          try { window.TradeNotifier && window.TradeNotifier.notify({
            title: `Open ${o.side==='long'?'Long':'Short'} ${o.symbol} ${o.mode==='cross'?'Cross':'Isolated'} ¬∑ ${o.leverage}x`,
            subtitle: 'Limit ¬∑ Filled',
            price: o.price,
            amount: o.amount,
            mode: o.mode,
            leverage: o.leverage,
            type: 'success',
          }); } catch(_) {}
          this.syncUserBalanceDebounced();
        } else {
          next.push(o);
        }
      }
      this.state.openOrders = next;
      this.renderOrders();
      this.saveState();
      return filledCount;
    }

    renderOrders() {
      if (!this.el.ordersTableBody) return;
      const rows = (this.state.openOrders || []).map(o => `
        <div class="row" data-id="${o.id}">
          <div class="cell-pair"><div class="pair">${o.symbol} Perp</div><div class="tags"><span class="chip">${o.mode==='cross'?'Cross':'Isolated'}</span><span class="chip">${o.leverage}x</span></div></div>
          <div>${new Date(o.createdAt||Date.now()).toLocaleString()}</div>
          <div>Limit</div>
          <div class="dir ${o.side}">${o.side==='long'?'Open Long':'Open Short'}</div>
          <div>--</div>
          <div>0.0000 BTC<br/>${o.amount.toFixed(4)} BTC</div>
          <div>--</div>
          <div>${this.format(o.price)}</div>
          <div>${this.format(o.price * o.amount / o.leverage)} USDT</div>
          <div>0.0000</div>
          <div><button class="cancel" data-id="${o.id}">Cancel</button></div>
        </div>
      `).join('');
      this.el.ordersTableBody.innerHTML = rows || '<div style="padding:12px; color:var(--text-color-secondary)">Ïò§Ìîà Ïò§Îçî ÏóÜÏùå</div>';
      this.el.ordersTableBody.querySelectorAll('button.cancel').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.getAttribute('data-id');
          this.state.openOrders = (this.state.openOrders || []).filter(o => o.id !== id);
          this.saveState();
          this.renderOrders();
        });
      });
    }

    render() {
      this.setSymbol(this.state.symbol);
      this.startOrderbook();
      this.renderDepth();
      this.renderPositions();
      this.updateCostPreview();
      this.renderPrices();
      this.renderAccountPanel();
      this.renderHistory && this.renderHistory();
      this.fetchLeverageBrackets();
    }

    async fetchLeverageBrackets() {
      try {
        const sym = (this.state.symbol || 'BTCUSDT').toUpperCase();
        // Ï∫êÏãú ÌôïÏù∏
        try {
          const cached = JSON.parse(localStorage.getItem('pt_mmr_'+sym)||'null');
          if (cached && cached.at && (Date.now()-cached.at < MMR_TTL)) {
            this._mmrBrackets = cached.brackets;
            return;
          }
        } catch(_) {}
        const res = await fetch(CONFIG.leverageBracketRest(sym));
        if (!res.ok) return;
        const data = await res.json();
        // ÏùëÎãµ ÌòïÌÉú: [{ symbol, brackets:[{ notionalCap, maintMarginRatio, ... }] }]
        const item = Array.isArray(data) ? data[0] : data;
        const brackets = (item && item.brackets) ? item.brackets.map(b => ({
          cap: Number(b.notionalCap),
          mmr: Number(b.maintMarginRatio)
        })) : null;
        if (brackets && brackets.length) {
          this._mmrBrackets = brackets;
          try { localStorage.setItem('pt_mmr_'+sym, JSON.stringify({ at: Date.now(), brackets })); } catch(_) {}
        }
      } catch (_) {}
    }

    renderPrices() {
      if (this.el.lastPrice) {
        const prev = this.prev.lastPrice;
        // ÏûêÏó∞Ïä§Îü¨Ïö¥ Î°§ÎßÅ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö© (1ÏûêÎ¶¨ Í≥†Ï†ï)
        this.renderRollingNumber(this.el.lastPrice, Number(this.state.lastPrice || 0), 1);
        this.prev.lastPrice = this.state.lastPrice;
      }
      if (this.el.mid) {
        // Ïò§ÎçîÎ∂Å Ï§ëÏïôÍ∞ÄÎèÑ Î∂ÄÎìúÎüΩÍ≤å
        this.renderRollingNumber(this.el.mid, Number(this.state.lastPrice || 0), 1);
      }
      if (this.el.price && !this.el.price.disabled && !this.priceTouched) {
        if (!this.el.price.value) this.el.price.value = (this.state.lastPrice || 0).toFixed(1);
      }
    }

    // Í∞ÄÍ≤© ÏÜåÏºìÏùÄ MarketSocketsÍ∞Ä Í¥ÄÎ¶¨

    // ÏÉàÎ°úÍ≥†Ïπ® ÏßÅÌõÑ Ï¶âÏãú 1Ìöå Í∞ÄÍ≤© Í∞±Ïã† (REST, Futures)
    async fetchInitialPrice() {
      try {
        const sym = (this.state.symbol || 'BTCUSDT').toUpperCase();
        if (this._priceAbort) { try { this._priceAbort.abort(); } catch(_) {} }
        this._priceAbort = new AbortController();
        const res = await fetch(CONFIG.tickerRest(sym), { signal: this._priceAbort.signal });
        if (!res.ok) return;
        const m = await res.json();
        const bid = parseFloat(m.bidPrice || m.b);
        const ask = parseFloat(m.askPrice || m.a);
        if (isFinite(bid) && isFinite(ask)) {
          const mid = (bid + ask) / 2;
          this.state.lastPrice = mid;
          this.renderPrices();
          this.updatePnL();
          this.firstPriceReceived = true;
        }
      } catch {}
    }

    async fetchDepth() {
      try {
        if (this._depthAbort) { try { this._depthAbort.abort(); } catch(_) {} }
        this._depthAbort = new AbortController();
        const res = await fetch(CONFIG.depthRest(this.state.symbol, 25), { signal: this._depthAbort.signal });
        if (!res.ok) throw new Error('depth ' + res.status);
        const data = await res.json();
        return data;
      } catch (e) {
        return null;
      }
    }

    async renderDepth() {
      const rowsEl = document.getElementById('orderbook-rows');
      const buyBar = document.getElementById('ob-buy-bar');
      const sellBar = document.getElementById('ob-sell-bar');
      const buyRatioEl = document.getElementById('ob-buy-ratio');
      const sellRatioEl = document.getElementById('ob-sell-ratio');
      if (!rowsEl) return;
      let { asks, bids } = this.orderbookState;
      // ÏµúÏ¥à Î°úÎìú Ïãú RESTÎ°ú Î≥¥Ï∂©
      if (!asks.length || !bids.length) {
        const depth = await this.fetchDepth();
        if (!depth) return;
        const norm = (arr) => (arr || [])
          .filter(x => Array.isArray(x) && x.length >= 2)
          .map(([p, q]) => ({ price: Number(p), size: Number(q) }))
          .filter(x => Number.isFinite(x.price) && Number.isFinite(x.size) && x.size > 0);
        asks = norm(depth.asks);
        bids = norm(depth.bids);
      }

      // Í≥†Ï†ï ÎùºÎçî Ï§ëÏïô Í∞ÄÍ≤© ÏÑ§Ï†ï/Ïú†ÏßÄ
      const tick = this.ladderTick;
      const last = Number(this.state.lastPrice || (asks[0]?.price || bids[0]?.price || 0));
      if (!this.ladderCenter) {
        this.ladderCenter = Math.round(last / tick) * tick;
      } else {
        const span = tick * (this.ladderLevels - 2);
        if (last > this.ladderCenter + span || last < this.ladderCenter - span) {
          this.ladderCenter = Math.round(last / tick) * tick;
        }
      }

      // Î≤ÑÌÇ∑ Îßµ Íµ¨Ï∂ï (0.1Îã®ÏúÑ)
      const askBuckets = new Map();
      for (const r of asks) {
        const bp = Math.ceil(r.price / tick) * tick;
        const k = bp.toFixed(1);
        const v = Number(r.size);
        if (isFinite(v) && v > 0) askBuckets.set(k, (askBuckets.get(k) || 0) + v);
      }
      const bidBuckets = new Map();
      for (const r of bids) {
        const bp = Math.floor(r.price / tick) * tick;
        const k = bp.toFixed(1);
        const v = Number(r.size);
        if (isFinite(v) && v > 0) bidBuckets.set(k, (bidBuckets.get(k) || 0) + v);
      }

      // Í∞ÄÏö© ÎÜíÏù¥Ïóê Îî± ÎßûÎäî Ìñâ Ïàò Í≥ÑÏÇ∞ ‚Üí ÎπàÏπ∏ Î∞©ÏßÄ
      const table = rowsEl.parentElement; // .orderbook-table
      const headerEl = table?.querySelector('.ob-header');
      const footerEl = table?.querySelector('.ob-footer');
      const rowsBoxH = rowsEl.clientHeight || (table ? Math.max(0, table.clientHeight - (headerEl?.clientHeight || 0) - (footerEl?.clientHeight || 0)) : 0);
      const cssRowH = table ? parseFloat(getComputedStyle(table).getPropertyValue('--ob-row-h')) : NaN;
      const rowH = Number.isFinite(cssRowH) && cssRowH > 0 ? cssRowH : 24;
      let capacity = rowsBoxH > 0 ? Math.max(9, Math.floor(rowsBoxH / rowH)) : 31; // ÏµúÏÜå 9Ìñâ(ASK x4 + MID + BID x4)
      // ÌôÄÏàò Í∞ïÏ†ú: Ï§ëÏïôÍ∞Ä 1Ìñâ Ìè¨Ìï® ÏúÑÌï¥
      if (capacity % 2 === 0) capacity -= 1;
      const topCount = Math.max(1, Math.floor((capacity - 1) / 2));
      const bottomCount = Math.max(1, capacity - 1 - topCount);

      // Í≥†Ï†ï Í∞ÄÍ≤© ÎùºÎçî ÏÉùÏÑ± (Í≥ÑÏÇ∞Îêú Ìñâ ÏàòÏóê ÎßûÏ∂§)
      const asksPrices = Array.from({ length: topCount }, (_, i) => Number((this.ladderCenter + tick * (i + 1)).toFixed(1)));
      const bidsPrices = Array.from({ length: bottomCount }, (_, i) => Number((this.ladderCenter - tick * (i + 1)).toFixed(1)));

      // ÎàÑÏ†Å Ìï©/Ï¥ùÌï© Í≥ÑÏÇ∞: Web WorkerÍ∞Ä ÏûàÏúºÎ©¥ ÏúÑÏûÑ (Î≤ÑÌÇ∑ ÏãúÍ∑∏ÎãàÏ≤ò ÎèôÏùº Ïãú Ïä§ÌÇµ)
      let askSizes, bidSizes, askCumMax, bidCumMax;
      if (this._obWorker) {
        const bucketSig = `${asksPrices[0]}-${asksPrices[asksPrices.length-1]}|${bidsPrices[0]}-${bidsPrices[bidsPrices.length-1]}|A${askBuckets.size}|B${bidBuckets.size}`;
        if (bucketSig !== this._obBucketSig) {
          this._obBucketSig = bucketSig;
          this._obLastPriceArrays = { asksPrices, bidsPrices };
          this._obWorker.postMessage({
            asksPrices,
            bidsPrices,
            askBuckets: Array.from(askBuckets.entries()),
            bidBuckets: Array.from(bidBuckets.entries())
          });
          // drawÎäî worker onmessageÏóêÏÑú Ïã§ÌñâÎê®
          return;
        }
        // ÏãúÍ∑∏ÎãàÏ≤ò ÎèôÏùº: ÎèôÍ∏∞ Í≥ÑÏÇ∞Î°ú Ï¶âÏãú Í∞±Ïã† (worker ÏùëÎãµ ÎåÄÍ∏∞ÌïòÏßÄ ÏïäÏùå)
        askSizes = asksPrices.map(p => Number((askBuckets.get(p.toFixed(1)) || 0).toFixed(4)));
        bidSizes = bidsPrices.map(p => Number((bidBuckets.get(p.toFixed(1)) || 0).toFixed(4)));
        askCumMax = Math.max(1, askSizes.reduce((a,b)=>a+b,0));
        bidCumMax = Math.max(1, bidSizes.reduce((a,b)=>a+b,0));
      } else {
        askSizes = asksPrices.map(p => Number((askBuckets.get(p.toFixed(1)) || 0).toFixed(4)));
        bidSizes = bidsPrices.map(p => Number((bidBuckets.get(p.toFixed(1)) || 0).toFixed(4)));
        askCumMax = Math.max(1, askSizes.reduce((a,b)=>a+b,0));
        bidCumMax = Math.max(1, bidSizes.reduce((a,b)=>a+b,0));
      }

      // Î†åÎçî (DOM Ïû¨ÏÇ¨Ïö©)
      this.drawOrderbook(asksPrices, bidsPrices, askSizes, bidSizes, askCumMax, bidCumMax);
    }

    drawOrderbook(asksPrices, bidsPrices, askSizes, bidSizes, askCumMax, bidCumMax) {
      const rowsEl = document.getElementById('orderbook-rows');
      if (!rowsEl) return;
      // ÎπÑÏú® Î∞î/ÌëúÏãú DOM Ï∫êÏãú (1Ìöå)
      if (!this._ratioEls) {
        this._ratioEls = {
          buyBar: document.getElementById('ob-buy-bar'),
          sellBar: document.getElementById('ob-sell-bar'),
          buyRatioEl: document.getElementById('ob-buy-ratio'),
          sellRatioEl: document.getElementById('ob-sell-ratio'),
        };
      }
      const { buyBar, sellBar, buyRatioEl, sellRatioEl } = this._ratioEls || {};

      // ÎùºÎçî ÌîÑÎùºÏù¥Ïä§ ÏÑ∏Ìä∏Í∞Ä Î∞îÎÄåÎ©¥ DOMÏùÑ Ïû¨Íµ¨ÏÑ±ÌïòÎèÑÎ°ù Ïã†Ìò∏
      // ÎùºÎçî ÌîÑÎùºÏù¥Ïä§ Í≤ΩÍ≥ÑÍ∞íÏúºÎ°ú Í∞ÑÎã®Ìïú ÏÑúÎ™Ö(Ï≤´/ÎßàÏßÄÎßâ Í∞í)Îßå ÎπÑÍµêÌï¥ ÎπÑÏö© Ï†àÍ∞ê
      const sig = `A:${asksPrices[0]}-${asksPrices[asksPrices.length-1]}|B:${bidsPrices[0]}-${bidsPrices[bidsPrices.length-1]}`;
      if (this._obLadderSig !== sig) {
        this._obLadderSig = sig;
        this._obMounted = false;
        this._obRowCache.clear();
      }
      // Î†åÎçî (DOM Ïû¨ÏÇ¨Ïö©)
      if (!this._obMounted) {
        rowsEl.innerHTML = '';
        this._obMounted = true;
        this._obRowCache.clear();
      }
      const rows = [];
      let totalAsk = 0, totalBid = 0;
      // ÏÉÅÎã®: ASK (Í∞ÄÍ≤© ÎÜíÏùå‚ÜíÎÇÆÏùå) Í≥†Ï†ï Í∞ØÏàò
      for (let i = asksPrices.length - 1; i >= 0; i--) {
        const price = asksPrices[i];
        const sz = askSizes[i] || 0;
        totalAsk += sz;
        const ratio = Math.min(1, totalAsk / askCumMax);
        const w = Math.round(ratio * 100);
        rows.push(`<div class=\"ob-row ask\" data-key=\"ask-${price.toFixed(1)}\" data-cum-size=\"${totalAsk}\" data-cum-notional=\"${(totalAsk*price).toFixed(2)}\" data-price=\"${price}\"><div class=\"bar\" style=\"background:#ef4444; width:${w}%; right:0; transition:width 180ms ease;\"></div><div class=\"price\">${this.format(price)}</div><div class=\"qty\" data-prev=\"${sz.toFixed(4)}\">${sz.toFixed(4)}</div><div class=\"total\" data-prev=\"${totalAsk.toFixed(4)}\">${totalAsk.toFixed(4)}</div></div>`);
      }
      rows.push(`<div class=\"ob-row mid\" data-key=\"mid\" style=\"position:sticky; top:0; background:var(--card-bg); font-weight:700;\"><div class=\"price\">${this.format(this.state.lastPrice)}</div><div></div><div></div></div>`);
      // ÌïòÎã®: BID (Í∞ÄÍ≤© ÎÇÆÏùå‚ÜíÎÜíÏùå) Í≥†Ï†ï Í∞ØÏàò
      for (let i = 0; i < bidsPrices.length; i++) {
        const price = bidsPrices[i];
        const sz = bidSizes[i] || 0;
        totalBid += sz;
        const ratio = Math.min(1, totalBid / bidCumMax);
        const w = Math.round(ratio * 100);
        rows.push(`<div class=\"ob-row bid\" data-key=\"bid-${price.toFixed(1)}\" data-cum-size=\"${totalBid}\" data-cum-notional=\"${(totalBid*price).toFixed(2)}\" data-price=\"${price}\"><div class=\"bar\" style=\"background:#10b981; width:${w}%; right:0; transition:width 180ms ease;\"></div><div class=\"price\">${this.format(price)}</div><div class=\"qty\" data-prev=\"${sz.toFixed(4)}\">${sz.toFixed(4)}</div><div class=\"total\" data-prev=\"${totalBid.toFixed(4)}\">${totalBid.toFixed(4)}</div></div>`);
      }
      // Ï¥àÍ∏∞ ÎßàÏö¥Ìä∏ ÏãúÏóêÎßå DOM ÏÉùÏÑ±, Ïù¥ÌõÑÏóêÎäî Ìï¥Îãπ ÌÇ§Îßå Í∞±Ïã†
      if (rowsEl.children.length === 0) {
        rowsEl.innerHTML = rows.join('');
        // Ï∫êÏãú Íµ¨Ï∂ï
        rowsEl.querySelectorAll('.ob-row').forEach((el) => {
          const key = el.getAttribute('data-key');
          if (key) this._obRowCache.set(key, el);
        });
      } else {
        // Í∞íÎßå Í∞±Ïã†
        const updateRow = (key, price, qty, cumSize, width, color) => {
          let el = this._obRowCache.get(key);
          if (!el) return; // ÎùºÎçî Î¶¨ÏÖãÏãú Ï¥àÍ∏∞ÌôîÎê®
          el.setAttribute('data-cum-size', String(cumSize));
          el.setAttribute('data-cum-notional', String((cumSize*price).toFixed(2)));
          const bar = el.querySelector('.bar');
          const priceEl = el.querySelector('.price');
          const qtyEl = el.querySelector('.qty');
          const totalEl = el.querySelector('.total');
          if (bar) { bar.style.transition = 'width 180ms ease'; bar.style.width = width + '%'; if (color) bar.style.background = color; }
          if (priceEl) priceEl.textContent = this.format(price);
          if (qtyEl) {
            const prev = Number(qtyEl.getAttribute('data-prev') || '0');
            qtyEl.setAttribute('data-prev', String(qty||0));
            this.animateNumber(qtyEl, prev, Number(qty||0), 200, (v)=> Number(v).toFixed(4));
          }
          if (totalEl) {
            const prevT = Number(totalEl.getAttribute('data-prev') || '0');
            totalEl.setAttribute('data-prev', String(cumSize||0));
            this.animateNumber(totalEl, prevT, Number(cumSize||0), 220, (v)=> Number(v).toFixed(4));
          }
        };
        // ÏÉÅÎã® ASK Ïó≠ÏàúÏúºÎ°ú Îã§Ïãú Í≥ÑÏÇ∞Îêú Î∞∞Ïó¥ Í∏∞Î∞ò Í∞±Ïã†
        let runningAsk = 0;
        for (let i = asksPrices.length - 1; i >= 0; i--) {
          const price = asksPrices[i];
          const sz = askSizes[i] || 0;
          runningAsk += sz;
          const ratio = Math.min(1, runningAsk / askCumMax);
          const w = Math.round(ratio * 100);
          updateRow(`ask-${price.toFixed(1)}`, price, sz, runningAsk, w, '#ef4444');
        }
        // Ï§ëÏïô
        const mid = this._obRowCache.get('mid');
        if (mid) {
          const priceEl = mid.querySelector('.price');
          if (priceEl) this.renderRollingNumber(priceEl, Number(this.state.lastPrice || 0), 1);
        }
        // ÌïòÎã® BID
        let runningBid = 0;
        for (let i = 0; i < bidsPrices.length; i++) {
          const price = bidsPrices[i];
          const sz = bidSizes[i] || 0;
          runningBid += sz;
          const ratio = Math.min(1, runningBid / bidCumMax);
          const w = Math.round(ratio * 100);
          updateRow(`bid-${price.toFixed(1)}`, price, sz, runningBid, w, '#10b981');
        }
      }

      // Î∂ÄÎìúÎü¨Ïö¥ ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌï¥ Îã§Ïùå ÌîÑÎ†àÏûÑÏóê Í∞ïÏ†ú Î¶¨ÌîåÎ°úÏö∞ ‚Üí Ìä∏ÎûúÏßÄÏÖò Ï†ÅÏö©
      requestAnimationFrame(() => {
        rowsEl.querySelectorAll('.ob-row .bar').forEach((el) => {
          el.getBoundingClientRect();
        });
      });

      const sumB = Number(bidSizes.reduce((a,b)=>a+b,0).toFixed(4));
      const sumS = Number(askSizes.reduce((a,b)=>a+b,0).toFixed(4));
      const total = sumB + sumS || 1;
      const bRatio = Math.round((sumB/total)*100);
      const sRatio = 100 - bRatio;
      if (buyBar && sellBar) {
        buyBar.style.width = bRatio + '%';
        sellBar.style.width = sRatio + '%';
      }
      if (buyRatioEl) buyRatioEl.textContent = String(bRatio);
      if (sellRatioEl) sellRatioEl.textContent = String(sRatio);
    }

    startOrderbook() {
      // Ìè¥ÎßÅ Ï†úÍ±∞, ÏÜåÏºì Í∏∞Î∞òÏúºÎ°ú Ï†ÑÌôòÌïòÏó¨ Ìã±Ìã± ÏõÄÏßÅÏù¥Í≤å
      this.stopOrderbookSocket?.();
      this.startOrderbookSocket?.();
    }

    stopOrderbookSocket() {
      try { this.orderbookSocket && this.orderbookSocket.close(); } catch(_) {}
      this.orderbookSocket = null;
    }

    startOrderbookSocket() {
      const sym = (this.state.symbol || 'BTCUSDT').toLowerCase();
      const url = CONFIG.orderbookDepthStream(sym);
      try { this.orderbookSocket && this.orderbookSocket.close(); } catch(_) {}
      let ws;
      try { ws = new WebSocket(url); } catch (e) { console.warn('OB socket create failed', e); return; }
      this.orderbookSocket = ws;
      let rafId = 0;
      const schedule = () => {
        // ÎîîÎ∞îÏö¥Ïä§ Ï†úÍ±∞, rAFÎ°úÎßå Î¨∂Ïñ¥ÏÑú Ï¶âÏãú Îã§Ïùå ÌîÑÎ†àÏûÑÏóê Î†åÎçî
        if (this._rafQueued) return;
        this._rafQueued = true;
        rafId = requestAnimationFrame(() => { this._rafQueued = false; this.renderDepth(); });
      };
      let lastFrame = 0;
      ws.onmessage = (ev) => {
        const now = performance.now();
        const MIN_INTERVAL = 33; // ~30fps
        if (now - lastFrame < MIN_INTERVAL) return;
        lastFrame = now;
        try {
          const text = ev.data;
          // Í∞ÑÎã® Ìï¥ÏãúÎ°ú ÎèôÏùº Î©îÏãúÏßÄ Ï§ëÎ≥µ Ï≤òÎ¶¨ Î∞©ÏßÄ
          const hash = (typeof text === 'string') ? (text.length + ':' + text.charCodeAt(0) + ':' + text.charCodeAt(text.length-1)) : '';
          if (hash && hash === this._obLastMsgHash) { return; }
          this._obLastMsgHash = hash;

          const m = typeof text === 'string' ? JSON.parse(text) : text;
          // diff-merge: Í∏∞Ï°¥ Îßµ ÏóÖÎç∞Ïù¥Ìä∏ (Í∞ÄÍ≤©ÏàòÏ§ÄÎßå ÏàòÏ†ï)
          const toMap = (arr, isBid) => {
            const map = new Map();
            for (const it of arr || []) { const p = Number(it[0]); const q = Number(it[1]); if (isFinite(p) && isFinite(q)) map.set(p, q); }
            return map;
          };
          const bidsMap = toMap(m.b, true);
          const asksMap = toMap(m.a, false);
          // Í∏∞Ï°¥ ÏÉÅÌÉú Î∞òÏòÅ
          const mergeSide = (prevArr, patchMap) => {
            const out = new Map();
            for (const r of prevArr || []) { out.set(r.price, r.size); }
            patchMap.forEach((q, p) => { if (q <= 0) out.delete(p); else out.set(p, q); });
            // ÏÉÅÏúÑ 50Î†àÎ≤®ÍπåÏßÄÎßå Ïú†ÏßÄ
            const sorted = [...out.entries()].sort((a,b)=> (b[0]-a[0]));
            return sorted.slice(0,50).map(([price,size]) => ({ price, size }));
          };
          this.orderbookState = {
            bids: mergeSide(this.orderbookState.bids, bidsMap),
            asks: mergeSide(this.orderbookState.asks, asksMap),
          };
          schedule();
          this._obRetry = 0; // Ï†ïÏÉÅ ÏàòÏã† Ïãú Î¶¨ÏÖã
        } catch (e) { /* ignore parse errors */ }
      };
      ws.onclose = () => {
        cancelAnimationFrame(rafId);
        // ÏßÄÏàò Î∞±Ïò§ÌîÑ (ÏµúÎåÄ 10Ï¥à)
        this._obRetry = Math.min(6, (this._obRetry||0) + 1);
        const base = Math.min(10000, 800 * Math.pow(2, this._obRetry));
        const jitter = base * (0.9 + Math.random()*0.2); // ¬±10%
        const delay = Math.round(jitter);
        setTimeout(()=> this.startOrderbookSocket(), delay);
      };
      ws.onerror = () => { try { ws.close(); } catch(_) {} };
    }

    renderPositions() {
      if (!this.el.positionsTableBody) return;
      const hasPos = this.state.positions.length > 0;
      if (!hasPos) {
        this.el.positionsTableBody.innerHTML = `<div style=\"padding:16px; color: var(--text-color-secondary);\">Î≥¥Ïú† Ìè¨ÏßÄÏÖòÏù¥ ÏóÜÏäµÎãàÎã§.</div>`;
        return;
      }
      this.el.positionsTableBody.innerHTML = this.state.positions
        .map((p) => {
          const mark = this.state.lastPrice;
          const pnl = this.calcPnL(p, mark);
          const pnlPct = ((pnl / Math.max(1e-8, p.entry * p.amount / p.leverage)) * 100); // ÎßàÏßÑ ÎåÄÎπÑ ÏàòÏùµÎ•† Í∑ºÏÇ¨
          const pnlCls = pnl >= 0 ? 'positive' : 'negative';
          const estLiq = this.calcLiqPrice(p);
          const notional = (p.entry * p.amount).toFixed(4);
          const rate = pnl > 0 ? 1.0 : (pnl < 0 ? 0.1 : 0);
          const estMined = Math.abs(pnl) * rate;
          return `
            <div class="row ${p.side}" data-id="${p.id}">
              <div class="cell-pair"><div class="pair">${p.symbol} Perp</div><div class="tags"><span class="chip">${p.mode==='cross'?'Cross':'Isolated'}</span><span class="chip">${p.leverage}x</span></div></div>
              <div class="dir ${p.side}">${p.amount.toFixed(4)} BTC</div>
              <div>${this.format(p.entry)}</div>
              <div>${this.format(mark)}</div>
              <div>${this.format(estLiq)}</div>
              <div>${(p.margin).toFixed(4)}</div>
              <div class="notional-usdt">${this.format(mark * p.amount)} USDT</div>
              <div class="pnl ${pnlCls}"><span class="pnl-val" data-prev="${pnl}">${pnl >= 0 ? '+' : ''}${this.formatFixed(pnl,3)}</span> USDT<br/><span class="pnl-percent">(${pnlPct>=0?'+':''}${pnlPct.toFixed(2)}%)</span></div>
              <div class="mined-cell" style="color:var(--primary-color);"><span class="mined-val" data-prev="${estMined}">${Number(estMined).toFixed(3)}</span> ONBIT</div>
              <div><button class="btn-mini" data-act="mkt-close">MKT Close</button></div>
              <div><input class="size-input" type="number" step="0.1" value="${mark.toFixed(1)}" /></div>
              <div><input class="size-input" data-role="qty" type="number" step="0.0001" min="0" max="${p.amount.toFixed(4)}" value="${p.amount.toFixed(4)}" /></div>
              <div class="actions"><button class="btn-mini close">Close</button></div>
            </div>
          `;
        })
        .join('');

      this.el.positionsTableBody.querySelectorAll('.row .close').forEach((btn) => {
        btn.addEventListener('click', (e) => {
          const id = e.target.closest('.row').getAttribute('data-id');
          this.closePosition(id);
        });
      });
      // ÏàòÎüâ ÏûÖÎ†• ÏÉÅÌïú: Ìè¨ÏßÄÏÖò Î≥¥Ïú† ÏàòÎüâÏùÑ Ï¥àÍ≥ºÌïòÏßÄ ÏïäÎèÑÎ°ù Ï†úÌïú
      this.el.positionsTableBody.querySelectorAll('.row [data-role="qty"]').forEach((inp) => {
        const row = inp.closest('.row');
        const id = row && row.getAttribute('data-id');
        const pos = this.state.positions.find(x=>x.id===id);
        if (!pos) return;
        const max = Number(pos.amount || 0);
        inp.setAttribute('max', String(max.toFixed ? max.toFixed(4) : max));
        inp.addEventListener('input', () => {
          let v = Number(inp.value || 0);
          if (v > max) v = max;
          if (v < 0) v = 0;
          inp.value = (Math.max(0, Math.min(max, v))).toFixed(4);
          // Ïä¨ÎùºÏù¥ÎçîÏôÄ ÎèôÍ∏∞Ìôî
          if (this._qtySlider && this._qtySlider.input === inp) {
            const pct = max > 0 ? Math.round((Number(inp.value||0) / max) * 100) : 0;
            this._qtySlider.range.value = String(Math.max(0, Math.min(100, pct)));
            this.updateQtySliderTooltip(pos, Number(inp.value||0), this._qtySlider);
          }
        });
        inp.addEventListener('blur', () => {
          let v = Number(inp.value || 0);
          if (!isFinite(v)) v = 0;
          if (v > max) v = max;
          if (v < 0) v = 0;
          inp.value = v.toFixed(4);
        });
        // ÌÅ¥Î¶≠/Ìè¨Ïª§Ïä§ Ïãú ÌçºÏÑºÌä∏ Ïä¨ÎùºÏù¥Îçî ÌëúÏãú
        const show = () => this.showCloseQtySlider(row, pos, inp);
        inp.addEventListener('focus', show);
        inp.addEventListener('click', show);
      });
      // MKT CLOSE Î≤ÑÌäº ‚Üí ÌòÑÏû¨ ÏãúÏû•Í∞Ä Í∏∞Ï§Ä Ï¶âÏãú Ï≤≠ÏÇ∞
      this.el.positionsTableBody.querySelectorAll('.row [data-act="mkt-close"]').forEach((btn) => {
        btn.addEventListener('click', (e) => {
          const id = e.target.closest('.row')?.getAttribute('data-id');
          if (id) this.closePosition(id);
        });
      });
      // add-margin Î≤ÑÌäº Ï†úÍ±∞Îê®
    }

    renderPositionsValuesOnly() {
      if (!this.el.positionsTableBody) return;
      this.el.positionsTableBody.querySelectorAll('.row').forEach((row) => {
        const id = row.getAttribute('data-id');
        const p = this.state.positions.find((x) => x.id === id);
        if (!p) return;
        const pnl = this.calcPnL(p, this.state.lastPrice);
        // ÌëúÍ∏∞Îäî ÏÇ¨Ïö© ÎßàÏßÑ ÎåÄÎπÑÎ°ú Í≥†Ï†ï
        const usedMargin = Math.max(1e-8, p.margin || 0);
        const pnlPct = (pnl / usedMargin) * 100;
        const pnlEl = row.querySelector('.pnl');
        if (pnlEl) {
          const rate = pnl > 0 ? 1.0 : (pnl < 0 ? 0.1 : 0);
          const estMined = Math.abs(pnl) * rate;
          // Ïà´Ïûê Ïï†ÎãàÎ©îÏù¥ÏÖò: PnL
          const pnlVal = pnlEl.querySelector('.pnl-val');
          if (pnlVal) {
            const prev = Number(pnlVal.getAttribute('data-prev') || '0');
            pnlVal.setAttribute('data-prev', String(pnl));
            this.animateNumber(pnlVal, prev, pnl, 400, (v)=> `${v>=0?'+':''}${this.formatFixed(v,3)}`);
          }
          // ÌçºÏÑºÌä∏ Í∞±Ïã† (Í≥†Ï†ï Îëê ÏûêÎ¶¨)
          const pnlPctEl = pnlEl.querySelector('.pnl-percent');
          if (pnlPctEl) {
            pnlPctEl.textContent = `(${pnlPct>=0?'+':''}${Number(pnlPct).toFixed(2)}%)`;
          }
          // Ï±ÑÍµ¥ Ïï†ÎãàÎ©îÏù¥ÏÖò
          const minedVal = row.querySelector('.mined-val');
          if (minedVal) {
            const prevM = Number(minedVal.getAttribute('data-prev') || '0');
            minedVal.setAttribute('data-prev', String(estMined));
            this.animateNumber(minedVal, prevM, estMined, 500, (v)=> `${Number(v).toFixed(3)}`);
          }
          pnlEl.classList.toggle('positive', pnl >= 0);
          pnlEl.classList.toggle('negative', pnl < 0);
        }
        // Ïã§ÏãúÍ∞Ñ Í∏àÏï°(Î™ÖÎ™©Í∞Ä) ÏóÖÎç∞Ïù¥Ìä∏
        const notionEl = row.querySelector('.notional-usdt');
        if (notionEl) notionEl.textContent = `${this.format(this.state.lastPrice * p.amount)} USDT`;
        // Ïã§ÏãúÍ∞Ñ ÌòÑÏû¨Í∞Ä/Ï≤≠ÏÇ∞Í∞Ä Í∞±Ïã†
        if (row.children && row.children.length > 5) {
          // ÌòÑÏû¨Í∞Ä Ïª¨Îüº (index 3)
          const markCol = row.children[3];
          if (markCol) {
            // Î≥¥Ïú† Ìè¨ÏßÄÏÖò ÌòÑÏû¨Í∞Ä ÏûêÏó∞Ïä§Îü¨Ïö¥ Î°§ÎßÅ Ï†ÅÏö© (1ÏûêÎ¶¨ Í≥†Ï†ï)
            this.renderRollingNumber(markCol, Number(this.state.lastPrice || 0), 1);
          }
          // ÏòàÏÉÅ Ï≤≠ÏÇ∞Í∞Ä Ïª¨Îüº (index 4) + Ìà¥ÌåÅ Ï†ïÎ≥¥ (ÍµêÏ∞® Ïª§Î≤ÑÎ¶¨ÏßÄ ÏïàÎÇ¥)
          const liqCol = row.children[4];
          if (liqCol) {
            const lp = this.calcLiqPrice(p);
            const val = (isFinite(lp) && lp > 0) ? lp : (p.side==='long' ? (p.entry*(1-1/Math.max(1.0001,Number(p.leverage)||1))) : (p.entry*(1+1/Math.max(1.0001,Number(p.leverage)||1))));
            // ÏûêÏó∞Ïä§Îü¨Ïö¥ Ïà´Ïûê Ï†ÑÌôò
            this.renderRollingNumber(liqCol, val, 2);
            try {
              if (!this._risk) this._risk = new window.RiskFunding({ getState: ()=>this.state, getBrackets: ()=>this._mmrBrackets });
              const tier = this._risk.getTierInfo && this._risk.getTierInfo(p);
              if (tier) {
                liqCol.title = `ÌëúÍ∏∞Îäî ÏÇ¨Ïö© ÎßàÏßÑ ÎåÄÎπÑ Í∏∞Ï§ÄÏûÖÎãàÎã§.\nÍµêÏ∞® Î™®ÎìúÏóêÏÑúÎäî ÏßÄÍ∞ëÏûîÍ≥†Î°ú Ïª§Î≤Ñ Í∞ÄÎä•.\nMMR: ${(tier.mmr*100).toFixed(3)}%\nNotional: ${this.format(tier.notional)} USDT${tier.cap?`\nTier Cap: ${this.format(tier.cap)} USDT (#${tier.idx})`:''}`;
              }
            } catch(_) {}
          }
        }
      });
    }

    // ===== Close Quantity Slider (Percent-based) =====
    showCloseQtySlider(rowEl, pos, qtyInput) {
      try {
        // Í∏∞Ï°¥ Ïä¨ÎùºÏù¥Îçî Ï†úÍ±∞
        if (this._qtySlider && this._qtySlider.wrapper && this._qtySlider.wrapper.parentNode) {
          this._qtySlider.wrapper.parentNode.removeChild(this._qtySlider.wrapper);
          this._qtySlider = null;
        }
        // ÎûòÌçº ÏÉùÏÑ±
        const wrap = document.createElement('div');
        wrap.style.position = 'absolute';
        // ÏúÑÏπòÎ•º Ï≤≠ÏÇ∞ ÏàòÎüâ ÏûÖÎ†• Î∞îÎ°ú ÏïÑÎûòÎ°ú Ï†úÌïúÎêú Ìè≠ÏúºÎ°ú ÌëúÏãú
        const rowRect = rowEl.getBoundingClientRect();
        const inpRect = qtyInput.getBoundingClientRect();
        const left = Math.max(0, (inpRect.left - rowRect.left) - 10);
        const top = (inpRect.bottom - rowRect.top) + 8;
        wrap.style.left = left + 'px';
        wrap.style.top = top + 'px';
        wrap.style.width = '260px';
        wrap.style.maxWidth = 'calc(100% - 24px)';
        wrap.style.padding = '10px 12px 12px';
        wrap.style.background = 'var(--bg-color)';
        wrap.style.border = '1px solid var(--border-color)';
        wrap.style.borderRadius = '10px';
        wrap.style.boxShadow = '0 8px 20px rgba(0,0,0,.25)';
        wrap.style.zIndex = '20';

        // Ïä¨ÎùºÏù¥Îçî UI
        const labelMin = document.createElement('div');
        labelMin.textContent = '0%';
        labelMin.style.color = 'var(--text-color-secondary)';
        const labelMax = document.createElement('div');
        labelMax.textContent = '100%';
        labelMax.style.color = 'var(--text-color-secondary)';
        const head = document.createElement('div');
        head.style.display = 'flex';
        head.style.justifyContent = 'space-between';
        head.style.marginBottom = '6px';
        head.appendChild(labelMin); head.appendChild(labelMax);

        const range = document.createElement('input');
        range.type = 'range';
        range.min = '0'; range.max = '100'; range.step = '1';
        range.style.width = '100%';
        range.style.height = '8px';
        range.value = (pos.amount>0) ? String(Math.round((Number(qtyInput.value||0)/pos.amount)*100)) : '0';

        // Ìà¥ÌåÅ
        const tip = document.createElement('div');
        tip.style.position = 'absolute';
        tip.style.top = '-32px';
        tip.style.transform = 'translateX(-50%)';
        tip.style.background = 'var(--card-bg)';
        tip.style.border = '1px solid var(--border-color)';
        tip.style.padding = '4px 8px';
        tip.style.borderRadius = '6px';
        tip.style.fontSize = '12px';
        tip.style.color = 'var(--text-color)';
        tip.style.display = 'none';

        const container = document.createElement('div');
        container.style.position = 'relative';
        container.appendChild(range);
        container.appendChild(tip);

        // ÎààÍ∏à(0/25/50/75/100) ÌëúÏãú Î∞è ÌÅ¥Î¶≠ÏúºÎ°ú Ï†êÌîÑ
        const marks = document.createElement('div');
        marks.style.position = 'absolute';
        marks.style.left = '0';
        marks.style.right = '0';
        marks.style.top = '50%';
        marks.style.transform = 'translateY(-50%)';
        marks.style.height = '0';
        const mkVals = [0,25,50,75,100];
        mkVals.forEach(p => {
          const dot = document.createElement('span');
          dot.style.position = 'absolute';
          dot.style.left = p+'%';
          dot.style.transform = 'translate(-50%, -50%)';
          dot.style.width = '8px';
          dot.style.height = '8px';
          dot.style.borderRadius = '50%';
          dot.style.background = 'rgba(255,255,255,.4)';
          dot.style.border = '1px solid var(--border-color)';
          dot.style.cursor = 'pointer';
          dot.addEventListener('click', () => { range.value = String(p); range.dispatchEvent(new Event('input')); });
          marks.appendChild(dot);
        });
        container.appendChild(marks);

        // Ìè¨ÏßÄÏÖò/Í∏àÏï° ÏöîÏïΩ Ìà¥ÌåÅ (ÏÉÅÎã®)
        const bubble = document.createElement('div');
        bubble.style.position = 'absolute';
        bubble.style.bottom = '100%';
        bubble.style.left = '0';
        bubble.style.transform = 'translateY(-8px)';
        bubble.style.background = 'var(--card-bg)';
        bubble.style.border = '1px solid var(--border-color)';
        bubble.style.padding = '8px 10px';
        bubble.style.borderRadius = '8px';
        bubble.style.color = 'var(--text-color)';
        bubble.style.fontSize = '12px';
        bubble.style.whiteSpace = 'nowrap';
        const updateBubble = (amt) => {
          bubble.textContent = `${amt.toFixed(4)} BTC`;
        };

        wrap.appendChild(bubble);
        wrap.appendChild(head);
        wrap.appendChild(container);

        // ÌñâÏóê Î∂ÄÏ∞©
        rowEl.style.position = rowEl.style.position || 'relative';
        rowEl.appendChild(wrap);

        const moveTip = (pct) => {
          const rect = range.getBoundingClientRect();
          const x = rect.left + (rect.width * (pct/100));
          tip.style.left = (x - rect.left) + 'px';
          tip.textContent = `${pct}%`;
        };

        const onInput = () => {
          const pct = Number(range.value||0);
          const amt = Math.max(0, Math.min(pos.amount, pos.amount * (pct/100)));
          qtyInput.value = amt.toFixed(4);
          this.updateQtySliderTooltip(pos, amt, { tip });
          moveTip(pct);
          updateBubble(amt);
          tip.style.display = 'block';
        };
        range.addEventListener('input', onInput);
        range.addEventListener('change', onInput);
        range.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft' || e.key === 'Left') {
            e.preventDefault();
            range.value = String(Math.max(0, Number(range.value||0) - 1));
            onInput();
          } else if (e.key === 'ArrowRight' || e.key === 'Right') {
            e.preventDefault();
            range.value = String(Math.min(100, Number(range.value||0) + 1));
            onInput();
          } else if (e.key === 'Escape' || e.key === 'Esc') {
            try { wrap.remove(); } catch(_) {}
            this._qtySlider = null;
          }
        });

        // Ïô∏Î∂Ä ÌÅ¥Î¶≠ Ïãú Îã´Í∏∞
        const onDocClick = (e) => {
          if (!wrap.contains(e.target) && e.target !== qtyInput) {
            try { wrap.remove(); } catch(_) {}
            document.removeEventListener('click', onDocClick);
            this._qtySlider = null;
          }
        };
        setTimeout(()=> document.addEventListener('click', onDocClick), 0);

        this._qtySlider = { wrapper: wrap, range, tip, input: qtyInput };
        // Ï¥àÍ∏∞ ÌëúÏãú
        onInput();
      } catch (_) {}
    }

    updateQtySliderTooltip(pos, amt, ctx) {
      if (!ctx || !ctx.tip) return;
      try {
        const pct = pos.amount > 0 ? Math.round((amt/pos.amount)*100) : 0;
        ctx.tip.textContent = `${pct}%`;
      } catch(_) {}
    }

    renderPositionsSkeleton() { /* removed by request */ }

    saveState() {
      // 300ms ÎîîÎ∞îÏö¥Ïä§ + Î≥ÄÍ≤Ω Í∞êÏßÄ
      try { clearTimeout(this._saveTimer); } catch(_) {}
      this._saveTimer = setTimeout(() => {
        try {
          const json = JSON.stringify(this.state);
          if (json !== this._lastSavedJson) {
            localStorage.setItem(STORAGE_KEY, json);
            this._lastSavedJson = json;
          }
        } catch {}
      }, 300);
    }

    renderAccountPanel() {
      const elEq = document.getElementById('acc-equity');
      const elAv = document.getElementById('acc-available');
      const elMg = document.getElementById('acc-margin');
      const elUp = document.getElementById('acc-upnl');
      const elEqBig = document.getElementById('acc-equity-big');
      const elWallet = document.getElementById('acc-wallet');
      const elUpBig = document.getElementById('acc-upnl-big');
      const elBonus = document.getElementById('acc-bonus');
      const elOnbit = document.getElementById('acc-onbit');

      const usedMargin = this.state.positions.reduce((sum, p) => sum + (p.margin), 0);
      const uPnL = this.state.positions.reduce((sum, p) => sum + this.calcPnL(p, this.state.lastPrice), 0);
      const available = this.state.balanceUSDT;
      const equity = this.state.equityUSDT;
      const marginBalance = available + usedMargin + uPnL; // ÏßÄÍ∞ë + Ìè¨ÏßÄÏÖò(ÏÇ¨Ïö© ÎßàÏßÑ) + ÎØ∏Ïã§ÌòÑÏÜêÏùµ

      // Small info (ÏûàÏùÑ ÎïåÎßå ÏóÖÎç∞Ïù¥Ìä∏)
      if (elEq) elEq.textContent = `${this.format(marginBalance)} USDT`;
      if (elAv) elAv.textContent = `${this.format(available)} USDT`;
      if (elMg) elMg.textContent = `${this.format(usedMargin)} USDT`;
      if (elUp) {
        const prevUp = this.prev.uPnL;
        elUp.textContent = `${uPnL>=0?'+':''}${this.format(uPnL)} USDT`;
        elUp.classList.toggle('up', uPnL >= 0);
        elUp.classList.toggle('down', uPnL < 0);
        // spark Ìö®Í≥º Ï†úÍ±∞
      }

      // Large summary ÎèôÍ∏∞Ìôî (ÏÉà ÎîîÏûêÏù∏) ‚Üí Ï†úÎ™©: ÎßàÏßÑ ÏûîÍ≥†
      if (elEqBig) {
        // Í≥†Ï†ï ÏÜåÏàò 4ÏûêÎ¶¨ + Rolling Number Animation Ï†ÅÏö© (ÏúÑÏπò Í≥†Ï†ï)
        this.renderRollingNumber(elEqBig, marginBalance, 4);
      }
      if (elWallet) elWallet.textContent = `$${this.format(available)}`;
      if (elUpBig) {
        const prevUp = this.prev.uPnL;
        elUpBig.textContent = `${uPnL>=0?'+':''}$${this.format(uPnL)}`;
        elUpBig.classList.toggle('up', uPnL >= 0);
        elUpBig.classList.toggle('down', uPnL < 0);
        // spark Ìö®Í≥º Ï†úÍ±∞
      }
      // Î≥¥ÎÑàÏä§Îäî ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå (ÏöîÏÜåÍ∞Ä ÎÇ®ÏïÑÏûàÏúºÎ©¥ Ïà®ÍπÄ)
      if (elBonus) elBonus.parentElement && (elBonus.parentElement.style.display = 'none');

      // ONBIT Ï±ÑÍµ¥ ÏûîÍ≥† Ïã§ÏãúÍ∞Ñ Î∞òÏòÅ
      // Ïô∏Î∂Ä(Î≥∏ Î™®Îìà)ÏóêÏÑú Ìï©ÏÇ∞ Í∞íÏùÑ Ï†úÏñ¥ÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑúÎäî Í±¥ÎìúÎ¶¨ÏßÄ ÏïäÏùå
      // (onbitMiner.externalControlled === true Ïù∏ ÏÉÅÌÉú)

      // Ïù¥Ï†Ñ Í∞í Ï†ÄÏû• (Îã§Ïùå Î≥ÄÌôî ÎåÄÎπÑ)
      this.prev.uPnL = uPnL;
      this.prev.marginBalance = marginBalance;
    }

    loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { ...defaultState };
        const parsed = JSON.parse(raw);
        return { ...defaultState, ...parsed, positions: parsed.positions || [] };
      } catch {
        return { ...defaultState };
      }
    }

    format(n) {
      if (n === undefined || n === null || isNaN(n)) return '-';
      const key = Math.round(Number(n) * 10000); // 4ÏûêÎ¶¨ Ï†ïÎ∞ÄÎèÑÎ°ú ÌÇ§ ÏÉùÏÑ±
      if (!this._fmtCache) { this._fmtCache = new Map(); this._fmtKeys = []; }
      if (this._fmtCache.has(key)) return this._fmtCache.get(key);
      const v = Number(n).toLocaleString('en-US', { maximumFractionDigits: 4 });
      this._fmtCache.set(key, v);
      this._fmtKeys.push(key);
      if (this._fmtKeys.length > 64) {
        const old = this._fmtKeys.shift();
        this._fmtCache.delete(old);
      }
      return v;
    }

    round(n, p) {
      const m = Math.pow(10, p);
      return Math.round(n * m) / m;
    }

    toAmount(n) {
      return this.round(n, this.amountPrecision);
    }

    // spark Ìö®Í≥º Ï†úÍ±∞Îê®

    animateNumber(el, from, to, duration, formatter) {
      if (!el) return;
      if (!isFinite(from) || !isFinite(to) || duration <= 0) {
        el.textContent = formatter ? formatter(to) : String(to);
        return;
      }
      if (Math.abs(to - from) < 1e-6) {
        el.textContent = formatter ? formatter(to) : String(to);
        return;
      }
      const start = performance.now();
      const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
      const seq = (el.__animSeq || 0) + 1;
      el.__animSeq = seq;
      const step = (now) => {
        if (el.__animSeq !== seq) return; // Ïù¥Ï†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∑®ÏÜå
        const t = Math.min(1, (now - start) / duration);
        const v = from + (to - from) * easeOutCubic(t);
        el.textContent = formatter ? formatter(v) : String(v);
        if (t < 1) requestAnimationFrame(step);
      };
      requestAnimationFrame(step);
    }

    // Rolling Number Animation: Í∞Å ÏûêÎ¶¨ÏàòÎ≥Ñ ÎîîÏßÄÌä∏ ÌîåÎ¶Ω ÏóÜÏù¥ÎèÑ Î∂ÄÎìúÎüΩÍ≥† Ï†ïÎ†¨ Ïú†ÏßÄ
    renderRollingNumber(targetEl, value, fixed = 4) {
      if (!targetEl) return;
      const prev = targetEl.__rollingPrev;
      const to = Number(value);
      const from = (typeof prev === 'number') ? prev : to;
      targetEl.__rollingPrev = to;
      const duration = 1000;
      const formatFixed = (n) => {
        const num = Number(n);
        if (!isFinite(num)) return '-';
        const parts = num.toFixed(fixed).split('.');
        parts[0] = Number(parts[0]).toLocaleString('en-US');
        return parts.join('.');
      };
      if (Math.abs(to - from) < 1e-9) {
        targetEl.textContent = formatFixed(to);
        return;
      }
      const start = performance.now();
      const seq = (targetEl.__rollingSeq || 0) + 1;
      targetEl.__rollingSeq = seq;
      const ease = (t) => 1 - Math.pow(1 - t, 3);
      const step = (now) => {
        if (targetEl.__rollingSeq !== seq) return;
        const t = Math.min(1, (now - start) / duration);
        const v = from + (to - from) * ease(t);
        targetEl.textContent = formatFixed(v);
        if (t < 1) requestAnimationFrame(step);
      };
      requestAnimationFrame(step);
    }

    // Í≥†Ï†ï ÏÜåÏàò Ìè¨Îß∑ÌÑ∞(Î∂ÄÌò∏ Ìè¨Ìï®)
    formatFixed(n, digits = 2) {
      const num = Number(n);
      if (!isFinite(num)) return '0.00';
      const abs = Math.abs(num).toFixed(digits);
      const withSep = Number(abs).toLocaleString('en-US', { minimumFractionDigits: digits, maximumFractionDigits: digits });
      return (num >= 0 ? withSep : '-' + withSep);
    }

    ensureObTooltip() {
      let el = document.getElementById('ob-tooltip');
      if (!el) {
        el = document.createElement('div');
        el.id = 'ob-tooltip';
        el.className = 'ob-tooltip';
        document.body.appendChild(el);
      }
      return el;
    }

    getTickSize(price) {
      if (price >= 100000) return 50;
      if (price >= 50000) return 10;
      if (price >= 10000) return 5;
      if (price >= 1000) return 0.5;
      return 0.1;
    }

    renderHistory() {
      if (!this.el || !document.getElementById('history-table-body')) return;
      const body = document.getElementById('history-table-body');
      const rows = (this.state.history || []).map(h => {
        const pnlPct = (h.pnl != null && h.leverage) ? ((h.pnl / Math.max(1e-8, h.avgPrice*h.filled/h.leverage))*100) : null;
        const pnlCls = h.pnl != null ? (h.pnl >= 0 ? 'positive' : 'negative') : '';
        const asset = h.symbol.startsWith('BTC') ? 'BTC' : 'ETH';
        const isClose = /Close|Forced/i.test(String(h.direction||''));
        const minedForRow = (isClose && h.pnl != null)
          ? (Math.abs(Number(h.pnl)) * (Number(h.pnl) >= 0 ? 0.01 : 0.001))
          : null;
        return `
          <div class="row" data-id="${h.id}">
            <div class="cell-pair"><div class="pair">${h.symbol} Perp</div><div class="tags"><span class="chip">${h.mode==='cross'?'Cross':'Isolated'}</span><span class="chip">${h.leverage}x</span></div></div>
            <div>${new Date(h.ts).toLocaleString()}</div>
            <div class="dir ${/Open/.test(h.direction)?'long':/Close Short|Forced Short/.test(h.direction)?'short':''}">${h.direction}</div>
            <div>${this.format(h.avgPrice)}<br/>${h.type}</div>
            <div>${(h.filled||0).toFixed(4)} ${asset}</div>
            <div class="pnl ${pnlCls}">${h.pnl==null?'--':(h.pnl>=0?'+':'')+this.format(h.pnl)}${pnlPct==null?'':`<br/><span class="pnl-percent">${pnlPct>=0?'+':''}${pnlPct.toFixed(2)}%</span>`}${minedForRow!=null ? `<br/><span class="mined" style="color:var(--primary-color);">${Number(minedForRow).toFixed(3)} ONBIT</span>` : ''}</div>
            <div>${(h.fee||0).toFixed(4)}</div>
          </div>
        `;
      }).join('');
      body.innerHTML = rows || '<div style="padding:12px; color:var(--text-color-secondary)">Í±∞Îûò ÎÇ¥Ïó≠ ÏóÜÏùå</div>';
    }
  }

  // Ï†ÑÏó≠ ÎÖ∏Ï∂ú
  window.paperTrading = new PaperTradingEngine();
})();


