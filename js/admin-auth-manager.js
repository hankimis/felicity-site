/**
 * üîê ADMIN AUTHENTICATION & SECURITY MANAGER
 * Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïñ¥ÎìúÎØº Ïù∏Ï¶ù Î∞è Î≥¥Ïïà Í¥ÄÎ¶¨ Î™®Îìà
 * 
 * Í∏∞Îä•:
 * - Îã§Ï∏µ Ïñ¥ÎìúÎØº Ïù∏Ï¶ù Í≤ÄÏ¶ù
 * - Ïö∞Ìöå ÏãúÎèÑ Ïã§ÏãúÍ∞Ñ ÌÉêÏßÄ
 * - Î≥¥Ïïà Ïù¥Î≤§Ìä∏ Î°úÍπÖ
 * - ÏÑ∏ÏÖò Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨
 * - ÏûêÎèô Î≥¥Ïïà Ï°∞Ïπò
 */

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-auth.js";
import { getFirestore, doc, getDoc, collection, addDoc, serverTimestamp, query, where, getDocs, limit, orderBy } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";
import { firebaseConfig } from '../firebase-config.js';

// üî• SECURITY CONFIGURATION
const SECURITY_CONFIG = {
    // ÌóàÏö©Îêú Ïñ¥ÎìúÎØº Ïù¥Î©îÏùº Î™©Î°ù
    ADMIN_EMAILS: [
        'admin@site.com',
        'admin@felicity.com',
        'manager@felicity.com',
        'hankim@felicity.com'
    ],
    
    // Î≥¥Ïïà ÏÑ§Ï†ï
    MAX_LOGIN_ATTEMPTS: 5,
    LOCKOUT_DURATION: 15 * 60 * 1000, // 15Î∂Ñ
    SESSION_TIMEOUT: 30 * 60 * 1000,  // 30Î∂Ñ
    
    // Í∞úÎ∞ú ÌôòÍ≤Ω ÏÑ§Ï†ï
    DEV_MODE: ['localhost', '127.0.0.1'].includes(window.location.hostname),
    
    // Î≥¥Ïïà Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ
    SECURITY_EVENTS: {
        LOGIN_SUCCESS: 'LOGIN_SUCCESS',
        LOGIN_FAILED: 'LOGIN_FAILED',
        BYPASS_ATTEMPT: 'BYPASS_ATTEMPT',
        CONSOLE_MANIPULATION: 'CONSOLE_MANIPULATION',
        DOM_MANIPULATION: 'DOM_MANIPULATION',
        UNAUTHORIZED_ACCESS: 'UNAUTHORIZED_ACCESS',
        SESSION_EXPIRED: 'SESSION_EXPIRED',
        PRIVILEGE_ESCALATION: 'PRIVILEGE_ESCALATION'
    }
};

class AdminAuthManager {
    constructor() {
        this.app = initializeApp(firebaseConfig);
        this.auth = getAuth(this.app);
        this.db = getFirestore(this.app);
        
        this.currentUser = null;
        this.isAdmin = false;
        this.sessionStartTime = null;
        this.lastActivityTime = null;
        this.securityMonitor = null;
        this.callbacks = {
            onAuthChange: [],
            onSecurityEvent: [],
            onAccessDenied: []
        };
        
        this.initializeSecurityMonitoring();
        this.setupAuthStateListener();
    }

    /**
     * üõ°Ô∏è Îã§Ï∏µ Ïñ¥ÎìúÎØº Ïù∏Ï¶ù Í≤ÄÏ¶ù
     */
    async validateAdminAccess(user = null) {
        const targetUser = user || this.currentUser;
        
        if (!targetUser) {
            await this.logSecurityEvent(SECURITY_CONFIG.SECURITY_EVENTS.UNAUTHORIZED_ACCESS, {
                reason: 'No authenticated user',
                timestamp: new Date().toISOString()
            });
            return false;
        }

        try {
            // 1Ï∞®: Firestore Ïó≠Ìï† Í≤ÄÏ¶ù
            const userDoc = await getDoc(doc(this.db, 'users', targetUser.uid));
            let isFirestoreAdmin = false;
            
            if (userDoc.exists()) {
                const userData = userDoc.data();
                isFirestoreAdmin = userData.role === 'admin' || userData.isAdmin === true;
                
                // Í≥ÑÏ†ï ÏÉÅÌÉú ÌôïÏù∏
                if (userData.isBlocked || userData.isDeactivated) {
                    await this.logSecurityEvent(SECURITY_CONFIG.SECURITY_EVENTS.UNAUTHORIZED_ACCESS, {
                        reason: 'Blocked or deactivated account',
                        userId: targetUser.uid,
                        email: targetUser.email
                    });
                    return false;
                }
            }

            // 2Ï∞®: Ïù¥Î©îÏùº Í∏∞Î∞ò Í≤ÄÏ¶ù (Î∞±ÏóÖ)
            const isEmailAdmin = SECURITY_CONFIG.ADMIN_EMAILS.includes(targetUser.email);

            // 3Ï∞®: Í∞úÎ∞ú ÌôòÍ≤Ω Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Í≤ÄÏ¶ù (Í∞úÎ∞úÏö©)
            let isLocalAdmin = false;
            if (SECURITY_CONFIG.DEV_MODE) {
                isLocalAdmin = localStorage.getItem('isAdmin') === 'true';
            }

            // 4Ï∞®: ÏÑ∏ÏÖò Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨
            const isSessionValid = this.validateSession();

            const finalResult = (isFirestoreAdmin || isEmailAdmin || isLocalAdmin) && isSessionValid;

            // Î≥¥Ïïà Ïù¥Î≤§Ìä∏ Î°úÍπÖ
            await this.logSecurityEvent(
                finalResult ? SECURITY_CONFIG.SECURITY_EVENTS.LOGIN_SUCCESS : SECURITY_CONFIG.SECURITY_EVENTS.LOGIN_FAILED,
                {
                    userId: targetUser.uid,
                    email: targetUser.email,
                    firestoreAdmin: isFirestoreAdmin,
                    emailAdmin: isEmailAdmin,
                    localAdmin: isLocalAdmin,
                    sessionValid: isSessionValid,
                    userAgent: navigator.userAgent,
                    timestamp: new Date().toISOString()
                }
            );

            return finalResult;

        } catch (error) {
            console.error('üö® Admin validation error:', error);
            await this.logSecurityEvent(SECURITY_CONFIG.SECURITY_EVENTS.UNAUTHORIZED_ACCESS, {
                reason: 'Validation error',
                error: error.message,
                userId: targetUser.uid
            });
            return false;
        }
    }

    /**
     * üîí ÏÑ∏ÏÖò Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨
     */
    validateSession() {
        const now = Date.now();
        
        // ÏÑ∏ÏÖò ÏãúÏûë ÏãúÍ∞Ñ ÌôïÏù∏
        if (!this.sessionStartTime) {
            this.sessionStartTime = now;
            this.lastActivityTime = now;
            return true;
        }

        // ÏÑ∏ÏÖò ÌÉÄÏûÑÏïÑÏõÉ Í≤ÄÏÇ¨
        if (now - this.lastActivityTime > SECURITY_CONFIG.SESSION_TIMEOUT) {
            this.logSecurityEvent(SECURITY_CONFIG.SECURITY_EVENTS.SESSION_EXPIRED, {
                sessionDuration: now - this.sessionStartTime,
                inactivityDuration: now - this.lastActivityTime
            });
            return false;
        }

        // ÌôúÎèô ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
        this.lastActivityTime = now;
        return true;
    }

    /**
     * üö® Ïã§ÏãúÍ∞Ñ Î≥¥Ïïà Î™®ÎãàÌÑ∞ÎßÅ Ï¥àÍ∏∞Ìôî
     */
    initializeSecurityMonitoring() {
        // ÏΩòÏÜî Ï°∞Ïûë ÌÉêÏßÄ
        this.monitorConsoleManipulation();
        
        // DOM Ï°∞Ïûë ÌÉêÏßÄ
        this.monitorDOMManipulation();
        
        // Í∞úÎ∞úÏûê ÎèÑÍµ¨ ÌÉêÏßÄ
        this.monitorDevTools();
        
        // ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ ÌÉêÏßÄ
        this.monitorKeyboardShortcuts();
    }

    /**
     * üîç ÏΩòÏÜî Ï°∞Ïûë ÌÉêÏßÄ
     */
    monitorConsoleManipulation() {
        const originalConsole = { ...console };
        
        ['log', 'warn', 'error', 'info'].forEach(method => {
            console[method] = (...args) => {
                const message = args.join(' ');
                
                // ÏùòÏã¨Ïä§Îü¨Ïö¥ ÏΩòÏÜî Î™ÖÎ†πÏñ¥ ÌÉêÏßÄ
                const suspiciousPatterns = [
                    /isAdmin\s*=\s*true/i,
                    /role\s*=\s*['"']admin['"']/i,
                    /localStorage\.setItem.*admin/i,
                    /firebase\.auth\(\)\.currentUser/i,
                    /document\.getElementById.*admin/i
                ];

                if (suspiciousPatterns.some(pattern => pattern.test(message))) {
                    this.logSecurityEvent(SECURITY_CONFIG.SECURITY_EVENTS.CONSOLE_MANIPULATION, {
                        command: message,
                        stack: new Error().stack,
                        timestamp: new Date().toISOString()
                    });
                }
                
                return originalConsole[method].apply(console, args);
            };
        });
    }

    /**
     * üîç DOM Ï°∞Ïûë ÌÉêÏßÄ
     */
    monitorDOMManipulation() {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'attributes') {
                    const element = mutation.target;
                    
                    // Ïñ¥ÎìúÎØº Í¥ÄÎ†® ÏöîÏÜåÏùò Ïä§ÌÉÄÏùº Î≥ÄÍ≤Ω ÌÉêÏßÄ
                    if (element.id && element.id.includes('admin') && 
                        mutation.attributeName === 'style') {
                        
                        const oldValue = mutation.oldValue;
                        const newValue = element.getAttribute('style');
                        
                        if (oldValue && oldValue.includes('display: none') && 
                            newValue && !newValue.includes('display: none')) {
                            
                            this.logSecurityEvent(SECURITY_CONFIG.SECURITY_EVENTS.DOM_MANIPULATION, {
                                elementId: element.id,
                                oldStyle: oldValue,
                                newStyle: newValue,
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                }
            });
        });

        observer.observe(document.body, {
            attributes: true,
            attributeOldValue: true,
            subtree: true,
            attributeFilter: ['style', 'class']
        });
    }

    /**
     * üîç Í∞úÎ∞úÏûê ÎèÑÍµ¨ ÌÉêÏßÄ
     */
    monitorDevTools() {
        let devtools = { open: false };
        
        setInterval(() => {
            if (window.outerHeight - window.innerHeight > 200 || 
                window.outerWidth - window.innerWidth > 200) {
                if (!devtools.open) {
                    devtools.open = true;
                    this.logSecurityEvent(SECURITY_CONFIG.SECURITY_EVENTS.BYPASS_ATTEMPT, {
                        type: 'Developer tools opened',
                        timestamp: new Date().toISOString()
                    });
                }
            } else {
                devtools.open = false;
            }
        }, 1000);
    }

    /**
     * üîç ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ ÌÉêÏßÄ
     */
    monitorKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
            // F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U Îì±
            const suspiciousKeys = [
                { key: 'F12' },
                { key: 'I', ctrlKey: true, shiftKey: true },
                { key: 'J', ctrlKey: true, shiftKey: true },
                { key: 'U', ctrlKey: true },
                { key: 'C', ctrlKey: true, shiftKey: true }
            ];

            const isSuspicious = suspiciousKeys.some(combo => {
                return e.key === combo.key && 
                       (!combo.ctrlKey || e.ctrlKey) && 
                       (!combo.shiftKey || e.shiftKey);
            });

            if (isSuspicious) {
                this.logSecurityEvent(SECURITY_CONFIG.SECURITY_EVENTS.BYPASS_ATTEMPT, {
                    type: 'Suspicious keyboard shortcut',
                    key: e.key,
                    ctrlKey: e.ctrlKey,
                    shiftKey: e.shiftKey,
                    timestamp: new Date().toISOString()
                });
            }
        });
    }

    /**
     * üìù Î≥¥Ïïà Ïù¥Î≤§Ìä∏ Î°úÍπÖ
     */
    async logSecurityEvent(eventType, details) {
        try {
            const securityLog = {
                eventType,
                details,
                userId: this.currentUser?.uid || 'anonymous',
                userEmail: this.currentUser?.email || 'anonymous',
                userAgent: navigator.userAgent,
                url: window.location.href,
                timestamp: serverTimestamp(),
                ipAddress: await this.getClientIP()
            };

            await addDoc(collection(this.db, 'security_logs'), securityLog);
            
            // ÏΩúÎ∞± Ïã§Ìñâ
            this.callbacks.onSecurityEvent.forEach(callback => {
                try {
                    callback(eventType, details);
                } catch (error) {
                    console.error('Security event callback error:', error);
                }
            });

        } catch (error) {
            console.error('üö® Failed to log security event:', error);
        }
    }

    /**
     * üåê ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ IP Ï£ºÏÜå ÌöçÎìù
     */
    async getClientIP() {
        try {
            const response = await fetch('https://api.ipify.org?format=json');
            const data = await response.json();
            return data.ip;
        } catch (error) {
            return 'unknown';
        }
    }

    /**
     * üë§ Ïù∏Ï¶ù ÏÉÅÌÉú Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
     */
    setupAuthStateListener() {
        onAuthStateChanged(this.auth, async (user) => {
            this.currentUser = user;
            
            if (user) {
                this.isAdmin = await this.validateAdminAccess(user);
                this.sessionStartTime = Date.now();
                this.lastActivityTime = Date.now();
            } else {
                this.isAdmin = false;
                this.sessionStartTime = null;
                this.lastActivityTime = null;
            }

            // ÏΩúÎ∞± Ïã§Ìñâ
            this.callbacks.onAuthChange.forEach(callback => {
                try {
                    callback(user, this.isAdmin);
                } catch (error) {
                    console.error('Auth change callback error:', error);
                }
            });
        });
    }

    /**
     * üìû Ïù¥Î≤§Ìä∏ ÏΩúÎ∞± Îì±Î°ù
     */
    onAuthStateChange(callback) {
        this.callbacks.onAuthChange.push(callback);
    }

    onSecurityEvent(callback) {
        this.callbacks.onSecurityEvent.push(callback);
    }

    onAccessDenied(callback) {
        this.callbacks.onAccessDenied.push(callback);
    }

    /**
     * üîê Ïñ¥ÎìúÎØº Í∂åÌïú ÌôïÏù∏ (Í≥µÍ∞ú Î©îÏÑúÎìú)
     */
    async isAdminUser() {
        if (!this.currentUser) return false;
        return await this.validateAdminAccess();
    }

    /**
     * üë§ ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î∞òÌôò
     */
    getCurrentUser() {
        return this.currentUser;
    }

    /**
     * üîì Î°úÍ∑∏ÏïÑÏõÉ
     */
    async logout() {
        try {
            await this.auth.signOut();
            this.currentUser = null;
            this.isAdmin = false;
            this.sessionStartTime = null;
            this.lastActivityTime = null;
            
            // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ïÎ¶¨
            localStorage.removeItem('isAdmin');
            
        } catch (error) {
            console.error('Logout error:', error);
        }
    }

    /**
     * üîß Í∞úÎ∞ú ÌôòÍ≤Ω ÎîîÎ≤ÑÍπÖ ÎèÑÍµ¨
     */
    enableDebugMode() {
        console.log('üîß AdminAuthManager Debug Mode Enabled');
        console.log('Current User:', this.currentUser);
        console.log('Is Admin:', this.isAdmin);
        console.log('Session Start:', this.sessionStartTime);
        console.log('Last Activity:', this.lastActivityTime);
    }
}

// üåü Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
const adminAuthManager = new AdminAuthManager();

// Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑú ÎîîÎ≤ÑÍ∑∏ Î™®Îìú ÌôúÏÑ±Ìôî
if (SECURITY_CONFIG.DEV_MODE) {
    adminAuthManager.enableDebugMode();
}

// Default export for ES6 modules (Ï†ÑÏó≠ Ïù∏Ïä§ÌÑ¥Ïä§)
export default adminAuthManager;
export { AdminAuthManager, SECURITY_CONFIG }; 